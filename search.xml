<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Leetcode-039]]></title>
      <url>%2F2017%2F02%2F11%2FLeetcode-039%2F</url>
      <content type="text"><![CDATA[Leetcode 039，获取所有set中相加为某值的相关操作。 题目Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7] and target 7, A solution set is: 1234[ [7], [2, 2, 3]] 解题思路采用backtracing的方法来解此题。 关键思路是通过每次减去某一元素，将减去后的值作为新的target继续迭代。这就需要一个前置位的vector来存放之前减去的元素（可重复），同时也要能够允许我们重复减去该元素直至target比该元素小。 代码见下，运行时间为12ms。 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); int size = candidates.size(); vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; prev; getSub(result, candidates, 0, target, prev); return result; &#125; void getSub(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; candidates, int index, int target, vector&lt;int&gt;&amp; prev)&#123; if(index &gt;= candidates.size()) return; int num = candidates[index]; int temp_target = target; if(temp_target == 0) return; while(num &lt;= temp_target)&#123; vector&lt;int&gt; prev_next = prev; getSub(result, candidates, index + 1, temp_target, prev_next); temp_target -= num; prev.push_back(num); &#125; if(temp_target == 0) result.push_back(prev); &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[038 Count and Say]]></title>
      <url>%2F2017%2F02%2F11%2FLeetcode-038%2F</url>
      <content type="text"><![CDATA[Leetcode 038，获取特定条件下数组中的某位的string的相关操作。 题目The count-and-say sequence is the sequence of integers beginning as follows:1, 11, 21, 1211, 111221, … 1 is read off as “one 1” or 11. 11 is read off as “two 1s” or 21. 21 is read off as “one 2, then one 1” or 1211. Given an integer n, generate the nth sequence. Note: The sequence of integers will be represented as a string. 解题思路这道题比较简单，用循环即可得到所需的string。 代码见下： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string countAndSay(int n) &#123; string result = "1"; for(int i = 0; i &lt; n - 1; i++)&#123; result = getSay(result); &#125; return result; &#125; string getSay(string input)&#123; int length = input.length(); int count = 1; char prev = 'a'; string result = ""; for(int i = 0; i &lt; length; i++)&#123; if(prev == input[i])&#123; count++; &#125; else&#123; count = 1; prev = input[i]; &#125; if((i + 1 == length) || (prev != input[i + 1]))&#123; result += (count + '0'); result += prev; &#125; &#125; return result; &#125; &#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[037 Sudoku Solver]]></title>
      <url>%2F2017%2F02%2F11%2FLeetcode-037%2F</url>
      <content type="text"><![CDATA[Leetcode 037，解数独题的相关操作。 题目Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character ‘.’. You may assume that there will be only one unique solution. 解题思路对于本道题，通过递归的方法来获得穷举。 先找到第一个’.’的位置，通过行、列以及9宫格确定可以填入其中的数字。（这里是用一个set的方法来确定） 然后再将set中的数字依次填入该位置中。需要注意的是，set只能通过iterator的方法来进行遍历。 然后用上递归的方法重复上述过程。如果当set为空时表示数独无效，需要返回上一级继续set的遍历。 代码见下，运行时间为96ms 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123;public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; getSudoku(board, 0, 0); &#125; bool getSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i_index, int j_index)&#123; for(int i = i_index; i &lt; 9; i++)&#123; int j; if(i == i_index) j = j_index; else j = 0; for(; j &lt; 9; j++)&#123; if(board[i][j] == '.')&#123; set&lt;char&gt; nums = &#123;'1','2','3','4','5','6','7','8','9'&#125;; validNumRow(board[i], nums); validNumCol(board, j, nums); validNumBox(board, i, j, nums); int size = nums.size(); if(size == 0) return false; for(set&lt;char&gt;::iterator it=nums.begin(); it != nums.end(); it++)&#123; vector&lt;vector&lt;char&gt;&gt; board_temp = board; board_temp[i][j] = *it; if(getSudoku(board_temp, i, j))&#123; board = board_temp; return true; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; void validNumRow(vector&lt;char&gt;&amp; board, set&lt;char&gt;&amp; nums)&#123; for(int i = 0; i &lt; 9; i++)&#123; if(board[i] != '.') nums.erase(board[i]); &#125; &#125; void validNumCol(vector&lt;vector&lt;char&gt;&gt;&amp; board, int index, set&lt;char&gt;&amp; nums)&#123; for(int i = 0; i &lt; 9; i++)&#123; if(board[i][index] != '.') nums.erase(board[i][index]); &#125; &#125; void validNumBox(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i_index, int j_index, set&lt;char&gt;&amp; nums)&#123; int row = i_index / 3; int column = j_index / 3; for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; 3; j++)&#123; if(board[row * 3 + i][column * 3 + j] !='.') nums.erase(board[row * 3 + i][column * 3 + j]); &#125; &#125; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[036 Valid Sudoku]]></title>
      <url>%2F2017%2F02%2F10%2FLeetcode-036%2F</url>
      <content type="text"><![CDATA[Leetcode 036，关于判断数独是否正确的相关操作。 题目Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. 解题思路分别判断行、列、每个九宫格是否valid（各9个） 代码见下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for(int i = 0; i &lt; 9; i++)&#123; if(!isValidRow(board[i]) || !isValidColumn(board, i) || !isValidBox(board, i))&#123; return false; &#125; &#125; return true; &#125; bool isValidRow(vector&lt;char&gt;&amp; board)&#123; unordered_map&lt;char, int&gt; charMap; for(int i = 0; i &lt; 9; i++)&#123; if(charMap.count(board[i]) &gt; 0)&#123; if(board[i] != '.') return false; &#125; else&#123; charMap[board[i]] = 1; &#125; &#125; return true; &#125; bool isValidColumn(vector&lt;vector&lt;char&gt;&gt;&amp; board, int index)&#123; unordered_map&lt;char, int&gt; charMap; char temp; for(int i = 0; i &lt; 9; i++)&#123; temp = board[i][index]; if(charMap.count(temp) &gt; 0)&#123; if(temp != '.') return false; &#125; else&#123; charMap[temp] = 1; &#125; &#125; return true; &#125; bool isValidBox(vector&lt;vector&lt;char&gt;&gt;&amp; board, int index)&#123; unordered_map&lt;char, int&gt; charMap; int row = index / 3; int column = index % 3; char temp; for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; 3; j++)&#123; temp = board[row * 3 + i][column * 3 + j]; if(charMap.count(temp) &gt; 0)&#123; if(temp != '.') return false; &#125; else&#123; charMap[temp] = 1; &#125; &#125; &#125; return true; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[035 Search Insert Position]]></title>
      <url>%2F2017%2F02%2F09%2FLeetcode-035%2F</url>
      <content type="text"><![CDATA[Leetcode 035，关于找到某元素在sorted array中的位置相关操作。 题目Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples.[1,3,5,6], 5 → 2 [1,3,5,6], 2 → 1 [1,3,5,6], 7 → 4 [1,3,5,6], 0 → 0 解题思路同样也是采用二分法，本题比较简单，具体代码见下 123456789101112131415161718192021222324class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int size = nums.size(); if(size == 0) return 0; int start = 0, end = size - 1, mid; while(start &lt; end)&#123; mid = (start + end) / 2; if(target &gt; nums[mid]) start = mid + 1; else end = mid; &#125; if(nums[start] == target) return start; else&#123; if(nums[start] &lt; target) return start + 1; else return start; &#125; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[034 Search for a Range]]></title>
      <url>%2F2017%2F02%2F09%2FLeetcode-034%2F</url>
      <content type="text"><![CDATA[Leetcode 034，关于从sorted array中找出某元素范围的相关操作。 题目Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 解题思路本题采用二分法来解，分别找出有序数组中该元素第一次出现的位置和最后一次出现的位置。 代码见下： 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result(2,-1); int size = nums.size(); if(size == 0) return result; int start = 0, end = size - 1, middle; while(start &lt; end)&#123; middle = (start + end) / 2; if(target &gt; nums[middle]) start = middle + 1; else end = middle; &#125; if(nums[start] != target) return result; else result[0] = start; end = size - 1; while(start &lt; end)&#123; middle = (start + end) / 2 + 1; if(target &lt; nums[middle]) end = middle - 1; else start = middle; &#125; result[1] = start; return result; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[033 Search in Rotated Sorted Array]]></title>
      <url>%2F2017%2F02%2F08%2FLeetcode-033%2F</url>
      <content type="text"><![CDATA[Leetcode 033，关于匹配某一变换过的sorted array中某元素的相关操作。 题目Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 解题思路这道题比较简单，用二分法即可得出答案。需要注意的一点是，array也有可能不翻转。注意这点后就不会出错了。 代码见下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int size = nums.size(); if(size == 0)&#123; return -1; &#125; int index = size / 2; int start = 0, end = size - 1; int prevIndex = -1; while(prevIndex != index)&#123; if(nums[index] == target) return index; else if(nums[start] == target) return start; else if(nums[end] == target) return end; else&#123; if(nums[index] &gt; nums[end])&#123; if(target &gt; nums[end])&#123; if(target &lt; nums[index]) end = index; else start = index; &#125; else if(target &lt; nums[end]) start = index; &#125; else if(nums[index] &lt; nums[start])&#123; if(target &gt; nums[start]) end = index; else if(target &lt; nums[start])&#123; if(target &lt; nums[index]) end = index; else start = index; &#125; &#125; else&#123; if(target &gt; nums[index]) start = index; else end = index; &#125; prevIndex = index; index = (start + end) / 2; &#125; &#125; return -1; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[032 Longest Valid Parentheses]]></title>
      <url>%2F2017%2F02%2F08%2FLeetcode-032%2F</url>
      <content type="text"><![CDATA[Leetcode 032，关于求一串字符串中有效括号的最大长度的相关操作。 题目Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. For “(()”, the longest valid parentheses substring is “()”, which has length = 2. Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4. 解题思路本题采用动态规划的方法来做。dp[i]表示前i个字符串中的有效括号的最大长度，如果第i个为右括号’)’，则我们需找到前i个字符串中最长括号前的字符，如果是左括号’(‘，则 dp[i] = dp[i - 1] + dp[prevIndex] + 2 ，如果不是这样的话 dp[i] = 0 代码见下，运行时间为12ms 123456789101112131415161718class Solution &#123;public: int longestValidParentheses(string s) &#123; int maxLength = 0; int len = s.length(); vector&lt;int&gt; dp(len + 1, 0); for(int i = 1; i &lt;= len; i++)&#123; int prevIndex = i - 2 - dp[i - 1]; if(prevIndex &lt; 0 || s[i - 1] == '(' || s[prevIndex] == ')') dp[i] = 0; else&#123; dp[i] = dp[i - 1] + 2 + dp[prevIndex]; maxLength = max(maxLength, dp[i]); &#125; &#125; return maxLength; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我看日剧]]></title>
      <url>%2F2017%2F02%2F08%2F%E6%88%91%E7%9C%8B%E6%97%A5%E5%89%A7%2F</url>
      <content type="text"><![CDATA[关于夏天的记忆，是浴衣，花火，以及长泽雅美。而关于日剧的记忆，我想，除了帅哥美女，就是对人性的入木三分，以及，对生活的不离不弃。 大概是被《逃避虽可耻但有用》中可爱的gakki所吸引，整个寒假我都沉浸在日剧的汪洋中，从最开始“单纯”欣赏各色女主的颜，到一步步被日剧的精彩攥着一刻不想脱身。 我猜想，大部分热爱日剧的人，应该和我一样，都是通过新垣结衣、长泽雅美、山下智久或是山田孝之等盛世美颜第一次与日剧结缘。不同于某半岛国千篇一律的妖艳美丽，风流倜傥，岛国演员们给人最深的印象就是各具风骚，可以是gakki治愈人心的回眸一笑，可以是长泽大妈令人痴迷的美腿，可以是户田惠梨香调皮的兔牙······不过，自古美人如名将，不教人间见白头，仅凭颜值的话，注定是无法长久的。那么又是什么给我们以长久的追剧动力呢？ 作为一个比较理性的观众，近年来的国产剧和韩剧令我望而却步的主要原因，一是对爱情的过分追求，达到无处不在的程度。不论是刑侦还是医疗剧，主线一定是主角的爱情生活，为爱痴狂，为爱奉献，为爱牺牲。的确我不能否认，爱情是人生中重要的一环，但是生活并不仅仅只有爱情，这种将其剥离然后高高贡起的做法着实令我厌恶。 而另一主因，就是剧的深度问题。对比日剧，国产剧和韩剧更像是流水化工厂的结晶，一模一样的套路配上似曾相识的表演，完成对爱情的讴歌和才子配佳人的美好结局。作为一部青春剧，《求婚大作战》就能让我感慨“花有重开时，人无再少年”，人生需要抓住每一个当下，这样才能在回首往昔时不留遗憾，无需一次次的“哈利路亚chance”。作为一部医疗剧，《code blue》能让我在了解直升机救援的同时深入医护人员的内心，体验日式的医患关系，治人需治心。作为脑洞剧的开山怪，《父女七日变》带我们走进了青春期父女的内心世界，感触温润亲情的同时也为编剧的想象力所折服。更别提《legal high》《半泽直树》这类直击社会的写实之作，更是用坚如磐石的三观圈住了大片的饭。 从这一部部十集左右的剧中，我们所看到的不单单是丰富的情感，精彩的表演，跌宕的情节，更有着对人性的挖掘和讨论，对生活的感触和憧憬，我想这或许就是日剧在剥离一位位盛世美颜后仍能深攥人心的原因吧。 或许，在未来的某一天，我也会抛弃日剧，但是，日剧曾带给我的那份感动，那份对生活的憧憬，将在我内心留下烙印，永久不褪。 【写在最后】有人说看韩剧找不到男朋友，看日剧找不到女朋友。我希望这不是真的。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[031 Next Permutation]]></title>
      <url>%2F2017%2F02%2F07%2FLeetcode-031%2F</url>
      <content type="text"><![CDATA[Leetcode 031，将一串数组变为字典序比其大一个的数组的相关操作。 题目Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 解题思路算法如下： 从前往后依次找出递减的子集，找出最后的一个的第一个数（即最大值）。 在递减子集最大值之后，找出比这个最大值前一个数大的数的最小值，并和最大数前的那个数交换。 在对交换后的子集进行sort排列，有小到大。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size == 0)&#123; return; &#125; int index = 0; int prev = nums[0]; for(int i = 1; i &lt; size; i++)&#123; if(nums[i] &gt; prev)&#123; index = i; &#125; prev = nums[i]; &#125; if(index == 0)&#123; sort(nums.begin(), nums.end()); return; &#125; int temp = nums[index - 1]; int secondLarge = nums[index]; int secIndex = index; for(int i = index + 1; i &lt; size; i++)&#123; if(nums[i] &lt; secondLarge &amp;&amp; nums[i] &gt; temp)&#123; secondLarge = nums[i]; secIndex = i; &#125; &#125; if(secIndex == index)&#123; nums[index - 1] = nums[index]; nums[index] = temp; &#125; else&#123; nums[index - 1] = nums[secIndex]; nums[secIndex] = temp; &#125; sort(nums.begin() + index , nums.end()); &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[030 Substring with Concatenation of All Words]]></title>
      <url>%2F2017%2F02%2F07%2FLeetcode-030%2F</url>
      <content type="text"><![CDATA[Leetcode 030，不用乘除法获得除法运算结果的相关操作。 题目You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. For example, given: s: “barfoothefoobarman” words: [“foo”, “bar”] You should return the indices: [0,9].(order does not matter). 解题思路这道题我思考了很久，一开始陷在了str.find()中，后来发现还是str.substr()一步步下来更加方便。 本题的一大难点就在于需要用一个容器来装载所有的词，以便于在确定一个词后从容器中将该词删除。这就需要我们用到hash table，一种十分便于查询的容器。 首先我们需要先将vector中的词存到map中，用数字表示其出现的次数。然后用str.substr()遍历整个字符串，看是否存在容器中。 代码见下： 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; unordered_map&lt;string, int&gt; wordMap; vector&lt;int&gt; result; int wordsNum = words.size(); for(int i = 0; i &lt; wordsNum; i++)&#123; if(wordMap.count(words[i])) wordMap[words[i]]++; else wordMap[words[i]] = 1; &#125; int wordSize = words[0].length(); int length = s.length() - wordSize * wordsNum; string temp; bool valid; for(int i = 0; i &lt;= length; i++)&#123; unordered_map&lt;string, int&gt; tempMap = wordMap; valid = true; for(int j = 0; j &lt; wordSize*wordsNum; j+=wordSize)&#123; temp = s.substr(i + j, wordSize); if(tempMap.count(temp))&#123; tempMap[temp]--; if(tempMap[temp] &lt; 0)&#123; valid = false; break; &#125; &#125; else&#123; valid = false; break; &#125; &#125; if(valid)&#123; result.push_back(i); &#125; &#125; return result; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[029 Divide Two Integers]]></title>
      <url>%2F2017%2F02%2F07%2FLeetcode-029%2F</url>
      <content type="text"><![CDATA[Leetcode 029，不用乘除法获得除法运算结果的相关操作。 题目Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. 解题思路本题的主要思路是利用binary search配合位的移动来实现。 将除数按位向左移动直至比被除数大或相等，被除数减去其右移一位得到此时的“余数”。对余数重复进行上述操作直至最后余数小于除数为止。 本题特别需要注意的是，int的范围。由于在左移的过程中有可能超出范围，所以在本题中我采用的是long形式来避免这种情况。 代码见下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int MAX_INT = 2147483647; int result = 0; int divide(int dividend, int divisor) &#123; if(dividend == -2147483648 &amp;&amp; divisor == -1) return MAX_INT; bool flag; if(dividend &lt; 0)&#123; if(divisor &gt; 0) flag = false; else flag = true; &#125; else&#123; if(divisor &gt; 0) flag = true; else flag = false; &#125; long dummy_dividend = abs(long(dividend)); long dummy_divisor = abs(long(divisor)); if(dummy_dividend &lt; dummy_divisor) return 0; while(dummy_dividend &gt;= dummy_divisor)&#123; dummy_dividend = getRe(dummy_dividend, dummy_divisor); &#125; if(flag) return result; else return (~result + 1); &#125; int getRe(long dividend, long divisor)&#123; int count = 0; while(dividend &gt; divisor)&#123; divisor = divisor&lt;&lt;1; count ++; &#125; if(dividend == divisor)&#123; result += 1 &lt;&lt; count; return 0; &#125; else&#123; result += 1 &lt;&lt; (count -1); return dividend - (divisor &gt;&gt; 1); &#125; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[028 Implement strStr()]]></title>
      <url>%2F2017%2F02%2F06%2FLeetcode-028%2F</url>
      <content type="text"><![CDATA[Leetcode 028，关于找出字符串中某一子集开始的位置的相关操作。 题目Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 解题思路采用string中的find函数一步到位。 1size_t find (const string&amp; str, size_t pos = 0) const; 函数中如果未找到，则返回string::npos，即-1. 代码见下： 123456class Solution &#123;public: int strStr(string haystack, string needle) &#123; return haystack.find(needle); &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[027 Remove Element]]></title>
      <url>%2F2017%2F02%2F06%2FLeetcode-027%2F</url>
      <content type="text"><![CDATA[Leetcode 027，关于去除数组中某一个值的相关操作。 题目Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example:Given input array nums = [3,2,2,3], val = 3 Your function should return length = 2, with the first two elements of nums being 2. 解题思路本题的方法是用two pointer的方法，将不为该值的元素放在前n个数组中，最后在对数组进行resize即可 代码见下： 123456789101112131415class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int i = 0; int size = nums.size(); for(int j = 0; j &lt; size; j++)&#123; if(nums[j] != val)&#123; nums[i] = nums[j]; i++; &#125; &#125; nums.resize(i); return i; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[026 Remove Duplicates from Sorted Array]]></title>
      <url>%2F2017%2F02%2F06%2FLeetcode-026%2F</url>
      <content type="text"><![CDATA[Leetcode 026，关于移除数组中相同元素的相关操作。 题目Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 解题思路转set处理看到这道题的第一反应就是先将vector转为set，自动去除了其中的重复元素，然后再将set转为vector。这里需要注意的一点是由于我们不能添加新的vector，因此在转为set后需要将原数组清空，再重新resize后从set中转入。 重要的一点在于set转vector时一定要事先确定vector的大小。 vector转set：1set&lt;int&gt; s(vec.begin(), vec.end()); set转vector：(vec事先确定大小)1copy(s.begin(), s.end(), vec.begin()); 代码见下： 12345678910class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; set&lt;int&gt; s(nums.begin(), nums.end()); nums.clear(); nums.resize(s.size(), 0); copy(s.begin(), s.end(), nums.begin()); return s.size(); &#125;&#125;; Two Pointers由于这是已经sorted array，所以我们只需要用two array 的方法将不重复的元素集中在前n个数组中，最后再对数组进行resize即可。 代码见下： 12345678910111213141516class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return 0; int i = 0; for(int j = 1; j &lt; nums.size(); j++)&#123; if(nums[i] != nums[j])&#123; i++; nums[i] = nums[j]; &#125; &#125; nums.resize(i + 1); return i+1; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[025 Reverse Nodes in k-Group]]></title>
      <url>%2F2017%2F02%2F06%2FLeetcode-025%2F</url>
      <content type="text"><![CDATA[Leetcode 025，关于交换链表中每k个节点的相关操作。 题目Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. For example,Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 解题思路本题的方法是用stack来对每k个链表进行reverse，如果剩余部分不够k长度，则保持原有的链表不进行reverse。 代码见下： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: ListNode* temp = new ListNode(0); ListNode* result = temp; ListNode* node; ListNode* reverseKGroup(ListNode* head, int k) &#123; while(head!=NULL)&#123; generateList(head, k); head = node; &#125; return result-&gt;next; &#125; void generateList(ListNode* head, int k)&#123; stack&lt;ListNode*&gt; stack; ListNode* temp2 = head; while(k &gt; 0)&#123; stack.push(head); if(head == NULL)&#123; temp-&gt;next = temp2; node = head; return; &#125; head = head-&gt;next; k--; &#125; while(!stack.empty())&#123; temp-&gt;next = stack.top(); temp = temp-&gt;next; temp-&gt;next = NULL; stack.pop(); &#125; node = head; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[024 Swap Nodes in Pairs]]></title>
      <url>%2F2017%2F02%2F06%2FLeetcode-024%2F</url>
      <content type="text"><![CDATA[Leetcode 024，关于交换链表中每两个节点的相关操作。 题目Given a linked list, swap every two adjacent nodes and return its head. For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解题思路对于本题而言，只需要交换节点即可，注意指针的指向，基本没有大问题。 1234567891011121314151617181920212223class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode* temp = new ListNode(0); ListNode* result = temp; while(head != NULL)&#123; ListNode* first = head; ListNode* second = head-&gt;next; if(second != NULL)&#123; head = second-&gt;next; temp-&gt;next = second; temp-&gt;next-&gt;next = first; temp-&gt;next-&gt;next-&gt;next = NULL; temp = temp-&gt;next-&gt;next; &#125; else&#123; temp-&gt;next = first; break; &#125; &#125; return result-&gt;next; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[023 Merge k Sorted Lists]]></title>
      <url>%2F2017%2F02%2F05%2FLeetcode-023%2F</url>
      <content type="text"><![CDATA[Leetcode 023，关于合并多个有序单链表的相关操作。 题目Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 解题思路直接比较链表头第一种比较简单的方法就是直接进行链表头的比较，取出较小的并移动其链表头。这种方法在运算时间上相对比较复杂。 代码见下，运行时间为模式为482ms。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode* temp = NULL; ListNode* result = temp; int size = lists.size(); int num = 0; int count, min, index; while(1)&#123; count = 0; min = 0; index = 0; for(int i = 0; i &lt; size; i++)&#123; if(lists[i] == NULL) continue; if(count == 0)&#123; min = lists[i]-&gt;val; index = i; &#125; else if(min &gt; lists[i]-&gt;val)&#123; min = lists[i]-&gt;val; index = i; &#125; count++; &#125; if(count == 0) break; if(num == 0)&#123; temp = lists[index]; result = temp; &#125; else&#123; temp-&gt;next = lists[index]; temp = temp-&gt;next; &#125; lists[index] = lists[index]-&gt;next; num++; &#125; return result; &#125;&#125;; 分治法(Divide and Conquer)这里我们可以考虑leetcode-021 Merge Two Sorted Lists。将vector中的链表两两先进行merge，采用递归的方法得到最终的结果。 思路可以参考wiki中的动图 代码见下，运行时间为32ms,时间复杂度为O(nklogk)，n为lists中最长的值 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if(lists.size() == 0)&#123; return NULL; &#125; return helper(lists, 0, lists.size() - 1); &#125; ListNode* helper(vector&lt;ListNode*&gt;&amp; lists, int left, int right)&#123; if(left &lt; right)&#123; int middle = (right + left) / 2; return mergeTwoLists(helper(lists, left, middle), helper(lists, middle + 1, right)); &#125; return lists[left]; &#125; ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* result = new ListNode(0); ListNode* head = result; result-&gt;next = l1; while(l1 != NULL &amp;&amp; l2 != NULL)&#123; if(l1-&gt;val &gt; l2-&gt;val)&#123; result-&gt;next = l2; l2 = l2-&gt;next; result-&gt;next-&gt;next = l1; &#125; else&#123; l1 = l1-&gt;next; &#125; result = result-&gt;next; &#125; if(l2 != NULL)&#123; result-&gt;next = l2; &#125; return head-&gt;next; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[022 Generate Parentheses]]></title>
      <url>%2F2017%2F02%2F05%2FLeetcode-022%2F</url>
      <content type="text"><![CDATA[Leetcode 022，关于获得所有符合条件的括号字符串数组的相关操作。 题目Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 解题思路本题可以用类似二叉树的思想来理解。示例图如下所示（n = 2） 要构建正确的括号数组，我们需要确认这两点： 当左括号数等于n时，只能放入右括号 当右括号数等于左括号数时，只能放入左括号（不等于n时） 所以，对于本题而言，采用递归的方法更加方便。在下列函数中，left代表着剩下课放入的左括号，right表示可以放入的右括号，通过递归，将符合条件的字符串压入vector中，得到最终的答案。 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;string&gt; result; vector&lt;string&gt; generateParenthesis(int n) &#123; if(n == 0) return result; int left = n, right = 0; getVector("", left, right); return result; &#125; void getVector(string str, int left, int right)&#123; if(right == 0 &amp;&amp; left == 0)&#123; result.push_back(str); return; &#125; if(right &gt; 0) getVector(str + ")", left, right - 1); if(left &gt; 0) getVector(str + "(", left - 1, right + 1); return; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[021 Merge Two Sorted Lists]]></title>
      <url>%2F2017%2F01%2F25%2FLeetcode-021%2F</url>
      <content type="text"><![CDATA[Leetcode 021，关于合并两个有序单链表的相关操作。 题目Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 解题思路链表头直接比较由于是有序单链表，所以直接进行比较生成一个新的单链表即可。 具体代码见下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* result = NULL; if(l1 == NULL)&#123; if(l2 == NULL)&#123; return result; &#125; else&#123; result = l2; l2 = l2-&gt;next; &#125; &#125; else if(l2 == NULL)&#123; result = l1; l1 = l1-&gt;next; &#125; else&#123; if(l1-&gt;val &gt; l2-&gt;val)&#123; result = l2; l2 = l2-&gt;next; &#125; else&#123; result = l1; l1 = l1-&gt;next; &#125; &#125; ListNode* head = result; while(l1 != NULL || l2 != NULL)&#123; if(l1 == NULL)&#123; result-&gt;next = l2; result = result-&gt;next; l2 = l2-&gt;next; &#125; else if(l2 == NULL)&#123; result -&gt;next = l1; result = result-&gt;next; l1 = l1-&gt;next; &#125; else&#123; if(l1-&gt;val &gt; l2-&gt;val)&#123; result-&gt;next = l2; result = result-&gt;next; l2 = l2-&gt;next; &#125; else&#123; result -&gt;next = l1; result = result-&gt;next; l1 = l1-&gt;next; &#125; &#125; &#125; result-&gt;next = NULL; return head; &#125;&#125;; 以一条链表为基准较之之前的方法，这种的一大优点就是它以一条链表作为基准进行比较，即假定next是l1，如果l2更小则将l2插入其中，否则直接移动l1。充分利用了原先的链表，减少了一些操作。 这种操作也可以被认为是归并操作中的迭代法。 具体代码见下，运行时间为12ms 1234567891011121314151617181920212223class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* result = new ListNode(0); ListNode* head = result; result-&gt;next = l1; while(l1 != NULL &amp;&amp; l2 != NULL)&#123; if(l1-&gt;val &gt; l2-&gt;val)&#123; result-&gt;next = l2; l2 = l2-&gt;next; result-&gt;next-&gt;next = l1; &#125; else&#123; l1 = l1-&gt;next; &#125; result = result-&gt;next; &#125; if(l2 != NULL)&#123; result-&gt;next = l2; &#125; return head-&gt;next; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[020 Valid Parentheses]]></title>
      <url>%2F2017%2F01%2F24%2FLeetcode-020%2F</url>
      <content type="text"><![CDATA[Leetcode 020，关于求字符串中的括号是否正确。 题目Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 解题思路对于本题，用栈的方法最为合适。左括号时压栈，右括号时判断栈顶是否匹配并出栈。最后判断栈是否清空。 代码见下： 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; stack; int length = s.length(); char temp; for(int i = 0; i &lt; length; i++)&#123; temp = s[i]; if(temp == '(' || temp == '[' || temp == '&#123;') stack.push(temp); else if(temp == ')' || temp == ']' || temp == '&#125;')&#123; if(stack.empty()) return false; if(temp == ')' &amp;&amp; stack.top()!='(') return false; else if(temp == ']' &amp;&amp; stack.top()!='[') return false; else if(temp == '&#125;' &amp;&amp; stack.top()!='&#123;') return false; else stack.pop(); &#125; &#125; if(stack.empty()) return true; else return false; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[019 Remove Nth Node]]></title>
      <url>%2F2017%2F01%2F24%2FLeetcode-019%2F</url>
      <content type="text"><![CDATA[Leetcode 019，关于去除单链表尾部第n个节点的相关处理。 题目Given a linked list, remove the nth node from the end of list and return its head. For example, 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note Given n will always be valid.Try to do this in one pass. 解题思路只能先从头指针遍历一遍，求得链表的长度，然后确定导数第n个的具体位置。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* list = head; int count = 1; while(list-&gt;next != NULL)&#123; count++; list = list-&gt;next; &#125; int index = count - n; if(index == 0)&#123; head = head-&gt;next; return head; &#125; int i = 0; ListNode* list2 = head; while(i &lt; index - 1)&#123; i++; list2 = list2-&gt;next; &#125; list2-&gt;next = list2-&gt;next-&gt;next; return head; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[018 4Sum]]></title>
      <url>%2F2017%2F01%2F24%2FLeetcode-018%2F</url>
      <content type="text"><![CDATA[Leetcode 018，关于求数组中四个元素和目标数相等的集合的相关处理。 题目Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题思路本题的思路和Leetcode-015一致，在该问的基础上再加一个循环来解决四个元素和的问题，这样在第一个循环里就和3Sum一模一样。 最终的运行时间为49ms，代码见下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; int length = nums.size(); if(length &lt; 4) return result; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; length - 3; i++)&#123; if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; threeSum(nums, i + 1, target); &#125; return result; &#125; void threeSum(vector&lt;int&gt;&amp; nums, int index, int target) &#123; int start, end; int length = nums.size(); for(int i = index; i &lt; length - 2; i++)&#123; if(i &gt; index &amp;&amp; nums[i] == nums[i - 1]) continue; start = i + 1; end = length - 1; twoSum(nums, nums[index - 1], nums[i], start, end, target, result); &#125; &#125; void twoSum(vector&lt;int&gt;&amp; nums, int temp1, int temp2, int start, int end, int target, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123; int sum; while(end &gt; start)&#123; sum = nums[start] + nums[end] + temp1 + temp2; if(sum &gt; target) end--; else if(sum &lt; target) start ++; else&#123; vector&lt;int&gt; temp; temp.push_back(temp1); temp.push_back(temp2); temp.push_back(nums[start]); temp.push_back(nums[end]); result.push_back(temp); end--; start++; while(end &gt; start &amp;&amp; nums[end] == nums[end + 1])&#123; end--; &#125; while(end &gt; start &amp;&amp; nums[start] == nums[start - 1])&#123; start++; &#125; &#125; &#125; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[017 Letter Combinations of a Phone Number]]></title>
      <url>%2F2017%2F01%2F24%2FLeetcode-017%2F</url>
      <content type="text"><![CDATA[Leetcode 017，关于求手机9宫格打字的相关处理。 题目Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. 12Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 解题思路本题采用backtracing的方法，在某种意义上也算是一种递归。 对于一个长度为n的input，我们先获取n-1 input时的答案，在这个基础上最终得到结果。 最终的运算时间为3ms 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; reference = &#123;&#123;"a","b","c"&#125;,&#123;"d","e","f"&#125;,&#123;"g","h","i"&#125;,&#123;"j","k","l"&#125;,&#123;"m","n","o"&#125;,&#123;"p","q","r","s"&#125;,&#123;"t","u","v"&#125;,&#123;"w","x","y","z"&#125;&#125;; vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; result; if(digits.find('0') != std::string::npos) return result; if(digits.find('1') != std::string::npos) return result; int length = digits.length(); if(length == 0) return result; else if(length == 1)&#123; result = reference[digits[0] - '2']; return result; &#125; else&#123; vector&lt;string&gt; temp_strs; vector&lt;string&gt; temp_result = letterCombinations(digits.substr(0, length - 1)); temp_strs = reference[digits[length - 1] - '2']; for(int i = 0; i &lt; temp_result.size(); i++)&#123; for(int j = 0; j &lt; temp_strs.size(); j ++)&#123; result.push_back(temp_result[i] + temp_strs[j]); &#125; &#125; &#125; return result; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[016 3Sum Closest]]></title>
      <url>%2F2017%2F01%2F24%2Fleetcode-016%2F</url>
      <content type="text"><![CDATA[Leetcode 016，关于求数组中三个元素和目标数最接近的相关处理。 题目Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 123For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 解题思路本题和Leetcode-015非常相似，我们同样采取two pointer的方法进行遍历，若有相等时则直接返回，否则需要遍历完后再返回最接近target值的sum。以下方法的时间复杂度为O(n^2)，运行时间为59ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: int sum = 0; int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int length = nums.size(); sort(nums.begin(), nums.end()); int start, end; int dif, min_dif = INT_MAX, close_sum = 0; for(int i = 0; i &lt; length - 2; i++)&#123; if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; start = i + 1; end = length - 1; dif = getSum(nums, nums[i], start, end, target); if(dif == 0) return target; if(dif &lt; min_dif)&#123; close_sum = sum; min_dif = dif; &#125; &#125; return close_sum; &#125; int getSum(vector&lt;int&gt;&amp; nums, int e, int start, int end, int target)&#123; int min_dif = INT_MAX; int dif; int temp_sum; while(end &gt; start)&#123; temp_sum = nums[start] + nums[end] + e; dif = temp_sum - target; if(abs(dif) &lt; min_dif)&#123; min_dif = abs(dif); sum = temp_sum; &#125; if(dif &gt; 0) end--; else if(dif &lt; 0) start ++; else return 0; &#125; return min_dif; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[015 3Sum]]></title>
      <url>%2F2017%2F01%2F24%2FLeetcode-015%2F</url>
      <content type="text"><![CDATA[Leetcode 015，关于求数组中所有和为0的3个元素集。 题目Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 1234567For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 解题思路本题的思路主要是结合leetcode-001里面的two sum方法来做。即求两个元素的和等于某一target。 在原函数的基础上稍作修改，构建一个新函数，在新函数中将符合条件的元素放入vector中。 本题采用的核心算法是two pointer的方法。先将input的数组进行升序sort，再从前往后遍历，将选取的值的作为two sum的target，利用two pointer法求出符合的元素。 具体代码见下，运行时间为62ms 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int length = nums.size(); vector&lt;vector&lt;int&gt;&gt; result; if(length &lt; 3) return result; sort(nums.begin(), nums.end()); int start, end; for(int i = 0; i &lt; length - 2; i++)&#123; if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; start = i + 1; end = length - 1; twoSum(nums, -1 * nums[i], start, end, result); &#125; return result; &#125; void twoSum(vector&lt;int&gt;&amp; nums, int target, int start, int end, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123; int sum; while(end &gt; start)&#123; sum = nums[start] + nums[end]; if(sum &gt; target) end--; else if(sum &lt; target) start ++; else&#123; vector&lt;int&gt; temp; temp.push_back(-1* target); temp.push_back(nums[start]); temp.push_back(nums[end]); result.push_back(temp); end--; start++; while(end &gt; start &amp;&amp; nums[end] == nums[end + 1])&#123; end--; &#125; while(end &gt; start &amp;&amp; nums[start] == nums[start - 1])&#123; start++; &#125; &#125; &#125; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[014 Longest Common Prefix]]></title>
      <url>%2F2017%2F01%2F19%2FLeetcode-014%2F</url>
      <content type="text"><![CDATA[Leetcode 014，关于求数字串数组最长共同前缀的相关处理。 题目Write a function to find the longest common prefix string amongst an array of strings. 解题思路主要利用string类里的函数substr取字符串的子集，再用compare函数比较字符串。本题中通过遍历字符串数组，确定最大共同前缀的长度。 具体代码见下，总运行时间为6ms 1234567891011121314151617181920212223class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; int vec_length = strs.size(); if (vec_length == 0) return ""; if (vec_length == 1)&#123; return strs[0]; &#125; int sub_length = strs[0].length(); string str_temp = strs[0]; for(int i = 1; i &lt; vec_length; i++)&#123; sub_length = (sub_length &gt; strs[i].length()) ? strs[i].length() : sub_length; while(str_temp.substr(0, sub_length).compare(strs[i].substr(0, sub_length)) &amp;&amp; (sub_length &gt; 0))&#123; sub_length--; &#125; &#125; if(sub_length == 0) return ""; else return str_temp.substr(0, sub_length); &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[013 Roman to Integer]]></title>
      <url>%2F2017%2F01%2F19%2FLeetcode-013%2F</url>
      <content type="text"><![CDATA[Leetcode 013，关于罗马数转数字的相关处理。 题目Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 解题思路此题比较容易，我们只需要在遍历字符串的过程中注意I，X，C这三种字符的后一位即可。 代码见下，总运行时间为36ms 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: int romanToInt(string s) &#123; int length = s.length(), num = 0; for(int i = 0; i &lt; length; i++)&#123; if(s[i] == 'M') num += 1000; else if(s[i] == 'D') num += 500; else if(s[i] == 'C')&#123; if(i &lt; length - 1)&#123; if(s[i + 1] == 'D' || s[i + 1] == 'M') num -= 100; else num += 100; &#125; else num += 100; &#125; else if(s[i] == 'L') num += 50; else if(s[i] == 'X')&#123; if(i &lt; length - 1)&#123; if(s[i + 1] == 'L' || s[i + 1] == 'C') num -= 10; else num += 10; &#125; else num += 10; &#125; else if(s[i] == 'V') num += 5; else&#123; if(i &lt; length - 1)&#123; if(s[i + 1] == 'V' || s[i + 1] == 'X') num -= 1; else num += 1; &#125; else num += 1; &#125; &#125; return num; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[012 Integer to Roman]]></title>
      <url>%2F2017%2F01%2F19%2FLeetcode-012%2F</url>
      <content type="text"><![CDATA[Leetcode 012，关于数字转罗马数相关处理。 题目Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 解题思路对于这道题而言，难度主要是在对罗马数的理解上，可以通过查阅wiki得到。再从较大的罗马数开始进行逐步判断。 具体代码见下，总运行时间为32ms 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public: string intToRoman(int num) &#123; vector&lt;char&gt; vec; int temp = num; while(temp - 1000 &gt;= 0)&#123; vec.push_back('M'); temp -= 1000; &#125; if(1000 - temp &lt;= 100)&#123; vec.push_back('C'); vec.push_back('M'); temp -= 900; &#125; if(temp - 500 &gt;= 0)&#123; vec.push_back('D'); temp -= 500; &#125; if(500 - temp &lt;= 100)&#123; vec.push_back('C'); vec.push_back('D'); temp -= 400; &#125; while(temp - 100 &gt;= 0)&#123; vec.push_back('C'); temp -= 100; &#125; if(100 - temp &lt;= 10)&#123; vec.push_back('X'); vec.push_back('C'); temp -= 90; &#125; if(temp - 50 &gt;= 0)&#123; vec.push_back('L'); temp -= 50; &#125; if(50 - temp &lt;= 10)&#123; vec.push_back('X'); vec.push_back('L'); temp -= 40; &#125; while(temp - 10 &gt;= 0)&#123; vec.push_back('X'); temp -= 10; &#125; if(10 - temp &lt;= 1)&#123; vec.push_back('I'); vec.push_back('X'); temp -= 9; &#125; if(temp - 5 &gt;= 0)&#123; vec.push_back('V'); temp -= 5; &#125; if(5 - temp &lt;= 1)&#123; vec.push_back('I'); vec.push_back('V'); temp -= 4; &#125; while(temp - 1 &gt;= 0)&#123; vec.push_back('I'); temp -= 1; &#125; string str(vec.begin(), vec.end()); return str; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[011 Container With Most Water]]></title>
      <url>%2F2017%2F01%2F19%2FLeetcode-011%2F</url>
      <content type="text"><![CDATA[Leetcode 011，关于数字数组的相关处理。 题目Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 解题思路Brute force拿到这道题我的第一个想法就是用两重循环来暴力求得答案，很遗憾这种方法最终以超时告终。在此不做赘述，仅贴在此处以示警戒。 Two Pointers这道题比较好的一种方法就是采用两个指针分别从头从尾向中间逼近。 通过观察我们可以发现，当头尾指针分别在i和j处时（i&lt;j），若ai为较小的那个，则若我们将j向左移，则得到的值一定小于刚才的值，所以在这种情况下，我们将i向右移，保持j不变。若aj较小时以此类推。 这样我们就能仅以时间复杂度O(n)就得到了最大值。 详细代码见下，运行时间为19ms 123456789101112131415161718192021class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int length = height.size(); int size = 0, max_s = 0; int start_index = 0, end_index = length - 1; while(start_index &lt; end_index)&#123; if(height[start_index] &lt; height[end_index])&#123; size = height[start_index] * (end_index - start_index); start_index++; &#125; else&#123; size = height[end_index] * (end_index - start_index); end_index--; &#125; if(size &gt; max_s) max_s = size; &#125; return max_s; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[巨人的陨落]]></title>
      <url>%2F2017%2F01%2F18%2F%E3%80%8A%E5%B7%A8%E4%BA%BA%E7%9A%84%E9%99%A8%E8%90%BD%E3%80%8B%2F</url>
      <content type="text"><![CDATA[都说历史是一个任人打扮的小姑娘，可架不住看客犀利的目光。从没有一段“淡妆浓抹总相宜”，浓妆艳抹和略施粉黛间的取舍全仗笔者的底蕴。 抽空拜读了肯·福莱特世纪三部曲之一的《巨人的陨落》，深有感触。其通过POV方式的以小见大，带我领略了一战前后的英德法俄美。从大国外交到战争，从权贵达官到平民百姓，书中从一位位主人公的视角出发，勾勒出了一段段充满感情的鲜活历史。 简介全书以4个国家中的5个家族为线索（俄国的别斯科夫、英国的菲兹赫伯特和威廉姆斯、德国的冯·乌尔里希、美国的杜瓦），通过第一人称POV手法，详细介绍了各自国家在一战前后的各种状况。 作者巧妙地将这5个家族定位在不同的阶级上，既有传统贵族的菲兹赫伯特与冯乌尔里希家族，也有新兴的杜瓦家族，同时还有工人阶级的威廉姆斯家族以及代表着传统俄国农民在变革时代间变迁的别斯科夫家族。 正是这巧妙的定位，使得我们得以如亲历般见证着： 一战爆发前英德法俄奥之间的外交对话。个人对这段格外着迷，以一个个国家精英的视角生动展现了国家政治外交上的隐忍与取舍。 一战中贵族的军官视角，平民的战士视角。正是一战加速了欧洲大陆传统贵族的没落。 俄国二月革命、十月革命的萌芽与诞生（列宁的归来） 战后协约国间形如分赃般的丑恶嘴脸，以及战后德国的糟糕境地。 本书以 Fall of Giants 为名，以一 fall 表示了欧洲大陆经过一战后的由盛转衰，同时还意味着战后的欧洲传统贵族开始走向了没落，战时战后尤以英国为主的妇女平权运动打破了以往男盛女衰的格局。 最令我感到惊讶的是作者写在文后的那句话 我的原则是：要么某一场景真实发生过，或者有可能发生；要么某些话真正说过，或者有可能说。如果我发现有某种原因让某种场景不可能真正发生，或不可能说出某些话——例如某个人物当时处于另一个国家，我便将其略去。 我想，这或许就是读完全文如此舒畅的原因了吧。 Thoughts如果说要让我从整本书中选出最有感触的一段，我想就要数关于俄国革命的部分了。 书中一段格雷戈里的内心活动一下子就抓住了我的心 一个孩子的成长就像一场革命，格雷戈里心想，你可以让他诞生，但后来如何就全然不在你的掌控之下了。 不像我国媒体般吹嘘十月（二月）革命的伟大，也不同西方媒体般对苏维埃敬而远之，书中以及其克制的手法，分别从俄国国内贵族和平民，以及英国贵族与平民的角度，多方面阐述了对革命的看法。 有沙皇治下的市民吃不上面包，有警察枪击手无寸铁的游行群众，也有革命之时大街上的打砸抢烧；有贵族不经审判绞死“侵占”自家空闲领地的农民，有军官贪污军需置士兵的死活与不顾，也有革命成功后苏维埃政权向贫穷农户强征口粮甚至枪毙不配合者。 的确，革命势在必行，但是在打破旧制度制定新制度的过程中，又有谁能确保自己不会成为那些打败恶龙最终成为恶龙的勇士呢？苏维埃是少数敢于站出来挑战沙皇权威的政党，以反对对人民的压迫，还人民以土地作为党的纲领，但是执政后也强抢粮食并枪毙不肯交粮的农民，甚至枪毙倒向孟什维克党的工人。 或许恶龙和勇士就是一条莫比乌斯带，我们永远不知道究竟是那一面。 写在文后：上述感想只是单纯讨论苏维埃政权，请勿发散思维！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[010 Regular Expression Matching]]></title>
      <url>%2F2017%2F01%2F18%2FLeetcode-010%2F</url>
      <content type="text"><![CDATA[Leetcode 010，关于字符串匹配。 题目Implement regular expression matching with support for ‘.’ and ‘*’. 12345678910111213141516&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true 解题思路这道题我感觉有一定难度，我采用了下面两种方法来解。 Recursion拿到这道题，我的第一个想法就是用递归的方法来解决。在进行递归之前，我需要先对字符串p进行一些处理。首先是将代表着重复的符号‘*’从字符串中取出，并在另一个int型数组中表示。若对应位置的数组值为-1，表示对应的字符串可以有重复或没有，为1则正常。 在此基础上构建递归函数，得到最终的结果。这里我的代码可能有些凌乱，进行了较多的判断，这些还需要改进，望见谅。 最终程序的运行时间是43ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class Solution &#123;public: bool isMatch(string s, string p) &#123; int length1 = s.length(); int length2 = p.length(); if(length1 == 0 &amp;&amp; length2 == 0) return true; vector&lt;char&gt; vec_s, vec_p; vector&lt;int&gt; vec_p_num; int i = 0, count = 0; while(i &lt; length1)&#123; count = 0; vec_s.push_back(s[i]); i += 1; &#125; i = 0; while(i &lt; length2)&#123; count = 0; vec_p.push_back(p[i]); i += 1; count += 1; if(i &lt; length2 &amp;&amp; p[i] == '*')&#123; count *= -1; i += 1; &#125; vec_p_num.push_back(count); &#125; return recursiveMatch(vec_s,vec_p,vec_p_num); &#125; bool recursiveMatch(vector&lt;char&gt; &amp;vec_s, vector&lt;char&gt; &amp;vec_p, vector&lt;int&gt; &amp;vec_p_num)&#123; vector&lt;char&gt; vec_s2, vec_p2; vector&lt;int&gt; vec_p_num2; int s_length = vec_s.size(); int p_length = vec_p.size(); int i = s_length - 1; int j = p_length - 1; if(i == 0 &amp;&amp; j == 0)&#123; if(vec_s[i] != vec_p[j] &amp;&amp; vec_p[j] != '.') return false; return true; &#125; if(j &lt; 0)&#123; return false; &#125; if(i &lt; 0)&#123; if(j &gt; 0)&#123; if(vec_p_num[j] != -1) return false; vec_p.pop_back(); vec_p_num.pop_back(); return recursiveMatch(vec_s,vec_p,vec_p_num); &#125; if(j == 0)&#123; if(vec_p_num[j] != -1) return false; return true; &#125; &#125; if (vec_s[i] == vec_p[j])&#123; if(vec_p_num[j] &gt; 0)&#123; vec_s.pop_back(); vec_p.pop_back(); vec_p_num.pop_back(); &#125; else&#123; vec_s2 = vec_s; vec_p2 = vec_p; vec_p_num2 = vec_p_num; vec_s.pop_back(); vec_p.pop_back(); vec_p_num.pop_back(); return recursiveMatch(vec_s2,vec_p,vec_p_num) || recursiveMatch(vec_s, vec_p2, vec_p_num2); &#125; &#125; else if(vec_p[j] != '.')&#123; if(vec_p_num[j] != -1) return false; else&#123; vec_p.pop_back(); vec_p_num.pop_back(); &#125; &#125; // here vec_p[j] == '.' else&#123; if(vec_p_num[j] &gt; 0)&#123; vec_s.pop_back(); vec_p.pop_back(); vec_p_num.pop_back(); &#125; // here vec_p_num[j] &lt; 0 else&#123; vec_s2 = vec_s; vec_p2 = vec_p; vec_p_num2 = vec_p_num; vec_s.pop_back(); vec_p.pop_back(); vec_p_num.pop_back(); return recursiveMatch(vec_s2,vec_p,vec_p_num) || recursiveMatch(vec_s, vec_p2, vec_p_num2); &#125; &#125; return recursiveMatch(vec_s,vec_p,vec_p_num); &#125;&#125;; Dynamic Programming对于本题而言，最好的方法是dp法的backtracing。 对于数组dp[j][k]而言，其表示的是字符串s前j个和字符串p前k个是否match。其可以从以下三处得到： dp[j - 1][k]：若match，则需要确定p[k - 1]是可以重复的，且与s[j - 1]match dp[j][k - 1]：若match，则需要确定p[k - 1]是可以省略的 dp[j - 1][k - 1]：若match，则需要确定s[j - 1]与p[k - 1]彼此match。 代码见下，运行时间为9ms，较之recursion方法性能得以大大提升。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: bool isMatch(string s, string p) &#123; int length1 = s.length(); int length2 = p.length(); if(length1 == 0 &amp;&amp; length2 == 0) return true; vector&lt;char&gt; vec_s, vec_p; vector&lt;int&gt; vec_p_num; int i = 0, count = 0; while(i &lt; length1)&#123; vec_s.push_back(s[i]); i += 1; &#125; i = 0; while(i &lt; length2)&#123; count = 0; vec_p.push_back(p[i]); i += 1; count += 1; if(i &lt; length2 &amp;&amp; p[i] == '*')&#123; count *= -1; i += 1; &#125; vec_p_num.push_back(count); &#125; length2 = vec_p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(length1 + 1, vector&lt;bool&gt;(length2 + 1, false)); for(int j = 0; j &lt;= length1; j++)&#123; for(int k = 0; k &lt;= length2; k++)&#123; if(j == 0)&#123; if(k == 0) dp[j][k] = true; else dp[j][k] = ((dp[j][k - 1]) &amp;&amp; (vec_p_num[k - 1] == -1)); &#125; else if(k == 0)&#123; dp[j][k] = false; &#125; else&#123; dp[j][k] = ((dp[j][k - 1]) &amp;&amp; (vec_p_num[k - 1] == -1)) || ((dp[j - 1][k]) &amp;&amp; ((vec_p_num[k - 1] == -1)) &amp;&amp; (((vec_s[j - 1] == vec_p[k - 1])) || vec_p[k - 1] == '.')) || (dp[j - 1][k - 1] &amp;&amp; (((vec_s[j - 1] == vec_p[k - 1])) || vec_p[k - 1] == '.')); &#125; &#125; &#125; return dp[length1][length2]; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[009 Palindrome Number]]></title>
      <url>%2F2017%2F01%2F17%2FLeetcode-009%2F</url>
      <content type="text"><![CDATA[Leetcode 009，判断数字是否是回文数。 题目Determine whether an integer is a palindrome. Do this without extra space. 解题思路将数字转成string来进行处理，需要注意的是任何的负数都不是回文数，因此在转换前可以先进行判断，若为负数直接返回false。具体代码详见下： 12345678910111213141516class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0) return false; char temp[64]; sprintf(temp, "%d", x); string s(temp); int length = s.length(); for(int i = 0; i &lt; length / 2; i++)&#123; if(s[i] != s[length - 1 - i]) return false; &#125; return true; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[008 String to Integer (atoi)]]></title>
      <url>%2F2017%2F01%2F16%2FLeetcode-008%2F</url>
      <content type="text"><![CDATA[Leetcode 008，关于字符串转数字相关处理。 题目Implement atoi to convert a string to an integer. RequirementThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 解题思路做本道题的时候，我事先并没有参考题目中给出的对应要求，先尝试着自己进行试验得到结果。 具体的思路还是顺序遍历这个字符串得到最终的结果。 相关细节可以直接参考上述的requirement。 具体代码见下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: int myAtoi(string str) &#123; bool positive = true; int length = str.length(); int num = 0; bool first = true; bool figure = true; for(int i = 0; i &lt; length; i++)&#123; if(str[i]== ' ' &amp;&amp; first &amp;&amp; figure) continue; if(str[i] == '-' &amp;&amp; first &amp;&amp; figure)&#123; positive = false; figure = false; continue; &#125; if(str[i] == '+' &amp;&amp; first &amp;&amp; figure)&#123; positive = true; figure = false; continue; &#125; if(str[i] &lt; '0' || str[i] &gt; '9')&#123; if (first)&#123; return 0; &#125; break; &#125; if(first)&#123; first = false; &#125; if(INT_MAX / 10 &lt; num)&#123; if(positive) return INT_MAX; else return INT_MIN; break; &#125; num *= 10; if(INT_MAX - (str[i] - '0') &lt; num)&#123; if(positive) return INT_MAX; else return INT_MIN; break; &#125; num += str[i] - '0'; &#125; if(positive) return num; else return num * -1; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[007 Reverse Integer]]></title>
      <url>%2F2017%2F01%2F16%2FLeetcode-007%2F</url>
      <content type="text"><![CDATA[Leetcode 007，关于数字取反相关处理。 题目Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 解题思路方法很简单，即用循环取余的方法，在此不作赘述。这里唯一需要注意的是当转换后的数字超出int的范围时要返回0，所以需要在循环中进行判断。 1234567891011121314151617181920class Solution &#123;public: int reverse(int x) &#123; int result = 0, temp = 1; if(x &lt; 0)&#123; x = abs(x); temp = -1; &#125; while(x != 0)&#123; if(INT_MAX / 10 &lt; result) return 0; result *= 10; if(INT_MAX - (x % 10) &lt; result) return 0; result += x % 10; x /= 10; &#125; return temp * result; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[006 ZigZag Conversion]]></title>
      <url>%2F2017%2F01%2F16%2FLeetcode-006%2F</url>
      <content type="text"><![CDATA[Leetcode 006，关于字符串和数组的相关处理。 题目The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) &lt; P A H N &lt; A P L S I I G &lt; Y I R And then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows: &lt; string convert(string text, int nRows); convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. 解题思路对于这道题，我的思路是先确定列数，再用行、列得到最终的字符串。 具体代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string convert(string s, int numRows) &#123; vector&lt;char&gt; vec; int length = s.length(); int column = 0, columnN = 0, columnRemainder = 0, index = 0; if (numRows == 1) return s; else&#123; columnN = length / (2 * numRows - 2); columnRemainder = length % (2 * numRows - 2); if(!columnRemainder) column = 2 * columnN; else column = columnN * 2 + (columnRemainder - 1) / numRows + 1; &#125; for(int i = 0; i &lt; numRows; i++)&#123; for(int j = 0; j &lt; column; j++)&#123; if (i == 0 || (i == (numRows - 1)))&#123; if(j % 2) continue; index = (2 * numRows - 2) * (j / 2) + i; &#125; else&#123; if(!(j % 2)) index = (2 * numRows - 2) * (j / 2) + i; else index = (2 * numRows - 2) * (j / 2) + 2 * numRows - 2 - i; &#125; if(index &lt; length) vec.push_back(s[index]); &#125; &#125; string str(vec.begin(), vec.end()); return str; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[004 Median of Two Sorted Arrays]]></title>
      <url>%2F2017%2F01%2F13%2FLeetcode-004%2F</url>
      <content type="text"><![CDATA[Leetcode 004，关于array相关处理。 题目There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 即找出两组按大小排列的数组的中位数。 解题思路由于两个数组都是按好大小排列好的sorted array，所以我的思路是每次pop出两个数组中最大的那个，最终得到想要的中位数。 具体代码见下，最后的运行时间为32ms，高于85%的答案，比较满意。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int size1 = nums1.size(), size2 = nums2.size(); bool odd = (bool)((size1 + size2) % 2); int count = 0; int tempNum = 0; int lastTempNum = 0; int countLimit = (size1 + size2) / 2 + 1; while(count &lt; countLimit)&#123; lastTempNum = tempNum; count ++; if (size1 == 0)&#123; if(size2 == 0)&#123; return NULL; &#125; size2--; tempNum = nums2.back(); nums2.pop_back(); continue; &#125; else if(size2 == 0)&#123; size1--; tempNum = nums1.back(); nums1.pop_back(); continue; &#125; if(nums1[size1 - 1] &gt; nums2[size2 - 1])&#123; size1--; tempNum = nums1.back(); nums1.pop_back(); &#125; else&#123; size2--; tempNum = nums2.back(); nums2.pop_back(); &#125; &#125; if (odd)&#123; return tempNum; &#125; else&#123; return 0.5 * (tempNum + lastTempNum); &#125; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[005 Longest Palindromic Substring]]></title>
      <url>%2F2017%2F01%2F12%2FLeetcode-005%2F</url>
      <content type="text"><![CDATA[Leetcode 005，关于回文和字符串相关处理。 题目Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 即找出字符串中的最大回文子集。 解题思路本题的核心在于字符串的相关处理。我的思路主要是确定子集中的最大长度和起始位置。这里主要展示我采用的两种方法。同时介绍题目推荐的方法。 brute-force一开始我用了比较笨的 brute-force 的方法。这种方法的时间复杂度为 N^3，在此不作推荐。 这种方法是从字符串的一头一尾开始搜索，一旦有相同的符号则进行下一步判断，判断再往里的两个字符是否相同，如果相同则进行下一步的判断。 这种方法最不好的地方在于进入循环判断的不一定是回文，很有可能出现靠近两边的部分回文但是中间部分不形成回文，这会浪费大量的运算资源而最终得不到一个回文数。 不过，最后这种方法还是可以通过测试，不过运算的时间有736ms之多。效果不好，在此仅作反面参考。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: string longestPalindrome(string s) &#123; int maxLength = 1, startIndex = 0, endIndex = 0, tempLength = 0; int length = s.length(); for(int i = 0; i &lt; length; i ++)&#123; for(int j = length - 1; j &gt; i; j--)&#123; if(s[i] == s[j])&#123; bool judge = false; tempLength = j - i + 1; if(tempLength &lt; 4)&#123; if(maxLength &lt; tempLength)&#123; maxLength = tempLength; startIndex = i; endIndex = j; &#125; judge = true; &#125; else&#123; bool ifBreak = false; for(int k = 1; k &lt; (tempLength / 2); k++)&#123; if(s[i + k] != s[j - k])&#123; ifBreak = true; break; &#125; &#125; if(!ifBreak)&#123; if(maxLength &lt; tempLength)&#123; maxLength = tempLength; startIndex = i; endIndex = j; &#125; judge = true; &#125; &#125; if(judge)&#123; break; &#125; &#125; &#125; &#125; return s.substr(startIndex, maxPalinLength); &#125;&#125;; 中心拓展上述的方法不是非常成功的基础上，我进一步思考，有没有办法可以使得我们只对回文数进行判断，这样就不会将宝贵的计算资源浪费在非回文数上，能够大大提高计算的效率。 为此，我想的方法是以字符串中的某一字符为中心，展开为一个回文数。这样不仅能够保证每个展开的都是回文数，同时还将时间复杂度降到了 N^2。 在这种方法中，我将奇数长度的回文数和偶数长度的回文数分别进行判断处理，这样也大大提高了运算的效率。 这种中心拓展的方法最后的运算时间为39ms，效果还算理想，不过离采用dp法还是有一定的差距。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: string longestPalindrome(string s) &#123; int length = s.length(); int startIndex = 0, tempLength = 0, maxPalinLength = 0; for (int i = 0; i &lt; length; i++) &#123; int length1 = i, length2 = length - i - 1; int maxLength = (length1 &gt;= length2) ? length2:length1; bool oddBreak = false, evenBreak = false; for (int j = 0; j &lt; maxLength + 1; j++)&#123; if (i == length - 1)&#123; evenBreak = true; &#125; if (!oddBreak)&#123; if (s[i - j] == s[i + j])&#123; tempLength = 2 * j + 1; if (tempLength &gt; maxPalinLength)&#123; maxPalinLength = tempLength; startIndex = i - j; &#125; &#125; else oddBreak = true; &#125; if (!evenBreak)&#123; if (s[i - j] == s[i + 1 + j])&#123; tempLength = 2 * j + 2; if (tempLength &gt; maxPalinLength)&#123; maxPalinLength = tempLength; startIndex = i - j; &#125; &#125; else evenBreak = true; &#125; if (evenBreak &amp;&amp; oddBreak)&#123; break; &#125; &#125; &#125; return s.substr(startIndex, maxPalinLength); &#125;&#125;; Dynamic Programming对于这道题而言，也可以用动态规划的方法进行。 我们知道，对于一个回文数而言，夹在其中间的那个子集一定是回文数。所以我们可以用一个二维的矩阵来判断字符串的一段子集是否是回文数。比如P[2][4]表示的就是字符串中以index 2为始，以index 4为结束的子集，若是回文数，则在进行P[1][5]判断的时候，只需直接判断s(1)是否等于s(5)即可。这样可以大大减少运算的时间。 不过最后的运行时间为202ms，不如方法二有效率。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: string longestPalindrome(string s) &#123; int length = s.length(); int Pa[length][length]; memset(Pa, 0, length*length*sizeof(int)); int maxLength=0, startIndex = 0, tempLength = 0; for (int i = 0; i &lt; length; i++)&#123; for (int j = 0; j &lt;= i; j++)&#123; if (j == i)&#123; Pa[j][i] = 1; &#125; else&#123; if(s[i] == s[j])&#123; if (i - j == 1)&#123; Pa[j][i] = 1; &#125; else&#123; if (Pa[j + 1][i - 1] == 1)&#123; Pa[j][i] = 1; &#125; &#125; &#125; &#125; if (Pa[j][i] == 1)&#123; tempLength = i - j + 1; if (tempLength &gt; maxLength)&#123; startIndex = j; maxLength = tempLength; &#125; &#125; &#125; &#125; return s.substr(startIndex, maxLength); &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Head First Civilization V]]></title>
      <url>%2F2017%2F01%2F09%2FCivilization-V%2F</url>
      <content type="text"><![CDATA[开篇让我们将地球的时钟拨到远古世纪，蜿蜒的河流边正孕育着文明的曙光，一队队移民正取下行装，准备在历史的长河中书写壮丽的篇章。一座座简陋的城市如雨后春笋般拔地而起，勾勒着美好的希望。手持木棒的勇士正开疆拓土，怀揣着一统天下的梦想。 上述这些画面描述的就是文明系列游戏的开场。一把文明游戏就仿佛是人类文明盛衰兴亡的缩影，带给我的感触绝非是一般游戏可比拟的。一句话，文明系列，不仅仅是游戏。 如果说有什么游戏值得我整整一天宅在电脑前废寝忘食，那一定是席大大的文明系列。而在6代bug不断，4代画质感人的今日，5代的美丽新世界显得格外诱人，在一个又一个“next turn”的指引下，一切都如白驹过隙，一晃而逝。（友情提示，没有闹钟的，没有自制力的，请远离文明系列） 宏观看文明虽然不像P社四萌那样有着极高的历史还原度，但是在宏观层面上对人类文明的量化和物化我从未见过如文明这般卓越的。它将人类文明的核心量化为科技和文化，而各个国家的实力物化为一个个城市以及单位，彼此之间相互影响，构成了整个复杂交错的文明世界，也让玩家看到了数千年来人类文明发展的缩影，闲暇之余颇有感触。 科技与文化在Civilization这系列游戏中，人类文明时刻被文化和科技点数推进着前行。随着科技的飞速发展，科技树茁壮成长着，一个个闻所未闻的建筑和单位出现在了城市的建设列表中，等待着一国之主的召唤。它们将进一步促进科技和文化的发展。而随着文化的积累，一项项政策被从上锁的黑箱拿上了台面，如同现在的城市规划和国家方针一样，指引着帝国步入黄金时代，迈入胜利的殿堂。 的确，人类的文明从来都是一个厚积而薄发的过程，没有前期挖石头的技术，哪来之后的石油、煤矿等的大发现？没有律法的出现，哪来的意识形态的选择？纵使给远古时代的人民一百个爱因斯坦，也注定不会有相对论和量子力学的丁点萌芽。这也是为什么，在游戏中，政策的选择局限于时代，科技的研发取决于之前的积累。 城市与单位玩家通过建造城市设施和调整市民工作来实现一个城市在粮食、产能、金钱、文化和信仰等方面的平衡，使之为帝国的发展贡献力量。每每在进入城市界面时，我的脑海中浮现的不是一个个单调的数字或是乏味的图标，而是一个个活生生的市民为了生计在城市之郊辛勤工作，为城市的产能和产粮做出微不足道的贡献。这样的生化当然难言快乐，尤其是当城市人口急剧膨胀之际，辛勤劳作了一天的市民不得不蜷曲在狭小的住处休息，这也是为什么在游戏中人口和城市数量的增长会带来大幅的不快乐。于国家而言，哪里有城市，哪里就有剥削，除非危及自身统治，人民的快乐不足为道，这又何尝不是现实生活的一个缩影呢？通过产出奢侈品和建设娱乐设施，市民们的快乐可以得到大幅提升，似乎被剥削的不快早已被抛之脑后，看来娱乐至死的年代由来已久啊。 如果说用一句话总结文明系列的精髓，那就是国家的利益高于一切。在游戏界面中，渺渺众生不过是一串串简单的数字，一队队忠义无双的士兵，一个个任劳任怨的劳工。他们在玩家的带领下，为着最终的胜利默默奉献着自己。游戏中，为了保住珍贵的笑脸，我们往往不惜将攻占的城市付之一炬，看着城市的人口一回合一回合地下降，直至城池变为废墟。为了省下足够的金钱，我们往往会将多余的单位就地处决，看着他们化作一道光永远消逝在历史的长河中。为了抢在AI之前造出奇观，我们往往会强制让市民忍饥挨饿，没日没夜地为产能贡献力量。沉浸在游戏中的我们又怎会意识到呢，这些不就是曾经的“嘉定三屠”，“扬州十日”，“长平之战”后的白起杀降，布尔什维克在战后依然实施的“战时共产主义”？ 唯一带点个人色彩的也就是在城市中产出的伟人了，他们有着与真实历史中某位名人相同的名字，而在游戏中他们的命运也不外乎是为了一项奇观、一项科技、一个作品或是一场战役，鞠躬尽瘁死而后已。可即便如此，他们还是一个个义无反顾地诞生于城市，为了帝国的繁荣昌盛前赴后继。真可谓是“苟利国家生死以，岂因祸福避趋之”。 国家和城邦文明系列游戏经久不息的一个原因，就在于多样的文明种类。玩家可以从二三十个文明中挑选一个进行游戏，而这二三十个文明也都各具特色。好玩的一点在于，游戏选取这些文明中的一位著名统治者，将其作为游戏中该文明的领袖。所以在游戏界面中，我们得以看这样的场景，骑在马上的拿破仑不屑地评论着我羸弱的士兵，白宫中的华盛顿义正言辞地进行抗议，雍容华贵的武则天不怒自威地否决了我的交易。正是这些文明领袖们将我们更好地带入了游戏中，将复杂难表的国家关系用领袖们的喜怒哀乐鲜活地呈现给了玩家。 在文明游戏中，国家关系是一个很重要的部分。两国间的良好关系是进行合作研究以及现金交易的前提。同时两国间的贸易也必须在非战争状态的条件下才能进行。这不就是现实的一个缩影吗？ 除了国家之外，在游戏中玩家还会碰到许多城邦，也就是现实中的“小国”。在第一次遇到时它们会给你一些钱，我总是开玩笑地说这是供奉给大国的礼金，摆出低调的姿态祈求乱世中的苟存。刚玩的时候我总是对这些城邦不屑一顾，对这些蝼蚁一直提出的烦人任务不理不睬。看着它们一个个成为了其他国家的盟友，想着这些小国送给你们也没什么用处，就这样一直开开心心地在家种田。一转眼国际形势骤变，昔日笑脸相迎的对手最终兵戎详见，我惊讶地发现那些城邦也都紧跟着它们主子的步伐，争先恐后地对我宣战。我当时第一个想到的不是打开存档，而是“这不就是北约？”。玩得越多，我越觉得城邦好处大大的，盟友会给你兵，给你文化，给你粮食，给你资源，给你信仰，还能给你快乐！而如果觉得完成城邦任务太麻烦，大可以拿钱砸，一堆堆金子砸在城邦的脸上，玩家就能享受到如同城邦爸爸一般的待遇，给吃给喝还能帮打架。 可以说文明中对国家和城邦的设定很好地诠释出了大国与小国间的外交政策与外交姿态。 胜利种类在Civilization V这款游戏中，总共有5种胜利的方式，而这5种方式也给玩家以不同的感悟。 外交胜利有人说，联合国建立的意义是为了让全世界更好地按照大国意志来运转，而事实也确有几分相似。诸如伊拉克战争、古巴禁运等事件就是大国通过对联合国的控制来实现对小国的支配，从而更好地实现自身利益。在文明游戏中也是亦然，一旦世界议会选出了世界领袖，那么也就意味着该国有着将自己的意志以世界议会中某一议题的形式强加于他国的能力，也就实现了外交上的胜利。 征服胜利文明V这款游戏也被称为野蛮V，不打仗怎么赢天下。一个无论科技和文化都远远落后的文明要想赢得游戏，只有用武力打破现有的状态。一旦取得了所有文明的首都，就取得了征服胜利。 作为一名爱好和平的种田流玩家，从个人理念出发我是十分不喜欢玩征服胜利的，一个原因自然是因为操纵“百万大军”攻城下寨是一件极其繁琐的事。还有一个很重要的原因是我在游戏过程中探索出来的：在飞船起飞前的一回合，我抱着玩一玩的心态将我的“小男孩一号”原子弹投向了身边的埃及，瞬间一座人口30+的主城血条只剩下了一半左右，周边的单位也是死伤惨重，城市中隐约还有人群大喊哭泣的声音，虽然知道这不过是游戏一场，但是内心总感觉有些堵。当然啦，打仗是一定要打的，不过我更喜欢逼得对面割地赔款，然后我在安安心心发战争财。 科技胜利从仰望星空开始的不仅仅有哲学，还有科学！将人类文明传播到更为浩瀚的宇宙一直是科学家们的梦想，也支撑着他们燃烧自己，成就科学的跃进。当飞船起飞的一刹那，人类文明的种子已播撒在银河系中，承载着无数人的梦想驶向远方。这也是我最喜欢的胜利模式！ 文化胜利当玩家的文化支配了其他文明，当那里的人民都穿着我们的衣服，说着我们的语言的时候，我们还能说这是别的国家吗？文化胜利的本质就是通过本国文化对他国潜移默化的影响，通过人民的融合实现国家的兼并。实现难度着实不小（一般都是打出来的。。。） 时间胜利（一般都关闭时间胜利）满满都是吐槽。。。在世界末日前的那一刻，上帝说，拯救那个分数最高的文明吧，于是就有了时间胜利。。。（2050年分数最高的玩家获胜） 结尾开了程序猿的脑洞写下了这篇civilization的Head First，文明带给我的不仅仅是绝佳的游戏体验，还让我有了很多思考，打算有时间出一篇Thinking in Civilization。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Concurrent Programming]]></title>
      <url>%2F2016%2F12%2F10%2Fconcurrent-programming%2F</url>
      <content type="text"><![CDATA[并发在应用程序中起着很重要的作用，本文将详细介绍应用级的并发 进程进程是构造并发程序最为简单的方法。在CSAPP的第八章中就已经介绍过：进程本质上就是一个执行中的程序的实例，每当我们运行一个程序的时候就会创建一个进程并在其上运行相关文件。而进程在真正运行的过程中并不是独占处理器的，根据不同的逻辑控制流（每个进程的PC值），不同的进程轮流使用处理器。如果不同的进程在运行过程中有时间的重叠，则两者之间是并发的关系。采用进程的并发方式可以在父子进程之间共享文件，同时两者不同的地址可以避免彼此信息的覆盖问题。但是这种方式不得不采用IPC（进程间通信）的方式来交换彼此的信息，而这是一种开销很大的方式，大大降低运行的速度。 I/O多路复用当我们在浏览一个网页的时候，服务器可以同时处理浏览器发送的请求和用户输入的指令，而这主要采用的就是I/O多路复用的方法。其核心思想就是采用select函数，要求内核挂起进程，仅当一个或多个I/O事件发生后才将其返回给应用程序。本质上这种方法下我们创建自己的逻辑流，利用I/O多路复用来进行流的调度。这种方法的一个最大的优点就是信息交换的便捷，共享数据来得更为高效(无需在流之间切换)，使我们对程序有着更好的掌控但是与此同时，与第一种方法相比，编码量的复杂度大大提升。而且一旦某一逻辑流在读某一文本，其他流就不能读了。这也是不是很高效的一点。 线程什么是线程与进程是运行在系统中的逻辑流对应的，线程是运行在进程中的逻辑流，每个线程都有着唯一的整数ID、栈指针、栈、计数器、寄存器等等，运行在一个进程中的线程共享该进程的整个虚拟地址空间。从本质上讲，这种方法更像是上述两种方法的结合。 线程是如何执行的所有的进程在最开始的时候都是单线程的，这个线程就是主线程。随后在某一时间点主线程会创建一个对等线程并与之一起并发运行（来回切换）由于线程的context对比进程而言要小得多，所以线程之间的切换也要快得多。主线程和对等线程之间基本上是相同的，都能读写相同的共享信息。 线程相关函数创建线程1234567#include &lt;pthread.h&gt; typedef void *(func)(void *);// Returns 0 if OK, nonzero on error int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg); // Returns thread ID of callerpthread_t pthread_self(void); 结束线程当调用下述函数时，主线程会等待所有对等线程终止时在终止自己和整个进程。否则则当线程运行完后隐式终止。 123// terminate threads#include &lt;pthread.h&gt; void pthread_exit(void *thread_return); 分离线程在线程被创建后，其默认是可结合的，即可以被其他线程回收杀死，而下面的函数则可以将其分离，仅当其终止时才自动释放存储。 123// detach threads#include &lt;pthread.h&gt; int pthread_detach(pthread_t tid); // Returns 0 if OK, nonzero on error 线程中同步变量各个线程彼此之间可以共享变量和文件，但是如果不加限制有时会造成同步错误。因此，在文件或是变量同步(读写)的过程中，并发的程序有着种种的限制。在本书讲pipeline的过程中就介绍过read after write的问题。在pipeline中如果先写后读则读的过程至少需要等待三个周期才能保证不出错（当然在forwarding的方法下我们可以将等待周期减为1个）。同样的，我们在并发线程中进行文件或是变量读写操作的时候，也会遇到类似的问题：如果在某一线程读取某一变量值的同时，另一线程正在对改写这一变量(这里的同时指的并不是完全意义上的同时，而是很短的时间)，由于读和写都要一定时间，这就可能会造成数据的错误。因此我们需要对线程间的变量同步加以限制。主要采用Posix中的 P 和 V 操作。 P(s)：加锁操作。若s非零则将其减1返回，否则挂起线程直至s非零。 V(s)：解锁操作。若有线程被P操作挂起则将s加1，重启该线程。 因此，我们可以通过 P 和 V 操作实现线程中的变量同步。以下代码展示了读者优先的线程，只要有一个读者在读，其他的读者就能忽略锁而毫无障碍的读取变量。 1234567891011121314151617181920212223// global variablesint readcnt;sem_t mutex, w;void reader(void)&#123; while(1)&#123; P(&amp;mutex); readcnt++; if (readcnt == 1) &#123; P(&amp;w); &#125; V(&amp;mutex); // do the reading P(&amp;mutex); if (readcnt == 0) &#123; V(&amp;w); &#125; V(&amp;mutex); &#125;&#125; 线程中的竞争问题如果我们在构建线程时，每次创建一个新的对等线程都是通过传递一个指向唯一整数ID的指针的话，很有可能会导致程序的错误，因为在这种情况下各个线程会产生竞争。而解决这种问题的方法也很简单，只需要用一个malloc函数为每个线程动态分配一个整数ID的指针，并将这个这个指针传递给构建线程的函数中。同时最后别忘了对指针进行free来避免memory leak。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[proxy-lab]]></title>
      <url>%2F2016%2F12%2F09%2Fproxy-lab%2F</url>
      <content type="text"><![CDATA[Proxy Lab 作为 cmu 18600 以及 15213 这两门课的最后一个lab，其综合性非常强。既需要掌握好 web programming 以及 concurrent programming 的相关知识，还需要结合之前涉及的 shell 和 cache 的相关操作。本文将详细介绍 proxy lab 的解题思路。 什么是proxy首先，我们需要知道什么是proxy？当我们平时打开浏览器的时候，输入一个URL，浏览器会向服务器发送相应的请求，服务器在接收到请求后会将相应的response发回给浏览器，如此循环往复从而加载完网页中的全部内容。此时所有的请求和响应之间的交流全是发生在 client (浏览器)和 server (服务器)之间的。而有时我们会在client和server之间添加代理，来进行相关的处理，这个代理就是实验要求我们完成的proxy。 proxy的大致示意图如下所示 实验准备在本次实验中，我们采用的浏览器是Firefox，设置代理的过程如下所示：打开设置中的高级，选择网络，点设置并按照如下设置（若proxy在本地则选择localhost或是127.0.0.1）需要注意的是，端口一定要和之后运行proxy时的端口一致 proxy如何处理request打开Firefox网页，Mac下alt + cmd + q，Win下按F12进行观察，点击每条可以显示出请求和响应的内容 通过这种方法，我们可以很轻松地看到请求和响应头。 而作为一个proxy，所需要做的事情主要有这么几件： 从请求中获取请求的方法，请求网址的hostname，path以及port（没有的话为80）(有多种方法解析，我采用的是正则表达式) 需要注意的是，本实验中不支持非get的方法，同时也不支持任何以HTTPS开头的网页请求。本实验中以501错误返回这类请求。 改变请求头中的一些内容（比如User-Agent，connection改为close） 添加 Proxy-Connection: close，来确定请求响应的交换是否结束 改变原先请求中的version。（从 HTTP/1.1 到HTTP/1.0） 对网页端发送请求进行修改之后，发送给服务器，再将response返回给网页端，如此循环往复直到网页内容加载完毕 处理多线程操作在完成上述内容之后，我们就实现了一个逐条处理网页端请求的proxy。但是在现实中这样的效率极其低下。所以对于我们的proxy还需要使其支持多线程操作。其所涉及的函数如下所示 1234int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);int pthread_detach(pthread_t thread); 其中pthread_create函数用于打开一个新的线程，通过调用start_routine这个函数，而其中的arg是start_routine函数的参数。特别要注意的是，arg一定要事先进行malloc，为每个线程ID分配一个独立的块，并将指向这个块的指针传给start_routine。不然线程会出现竞争问题导致错误。同时在结束线程时一定要释放这些块来避免memory leak（我就是在这里跪了很久的。。。） 而第二个函数是用于在线程中防止线程被其他线程回收或杀死。 在第一步中加入上述函数，基本上就能够实现proxy的多线程操作的部分。 存储网页内容以上的proxy已经基本完成了代理的要求。不过当我们重复请求某一个网址的时候，它还是要重新加载一遍，这就有点低效了。如果我们能够把之前网页端获取的响应存下来呢？这样当我们重复加载的时候就无需连接到服务器了。所以，我们还要让我们的proxy能够存储网页的内容。在本次实验中，我用一个类似于队列的双向链表来表示存储的cache。proxy在每次处理完网页端发来的请求后，先遍历整个链表，看是否有相同的request存在cache中，如果有就直接获取对应的response。没有的话就现将请求发动到server，将server返回的response写入到cache中。在具体的操作中，我采用的是FIFO，每次都将新的request/response加在链表的头。一旦cache存储已满，就从尾部pop。需要注意的是，一旦找到匹配的request之后，我们还需要将对应的node移到链表的头指针处。这样才符合FIFO。 上述就是我对与proxy lab的总结，希望大家都能做出一个完美的proxy！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[去雾算法浅析]]></title>
      <url>%2F2016%2F11%2F29%2F%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[何凯明博士在09年以 “Single Image Haze Removal Using Dark Channel Prior” 一文技惊四座。此文甚至成为09年的CVPR最佳论文。本篇博文将对这种去雾算法进行简要的分析，并通过自己的实现来更好的进行介绍。 算法核心介绍Foggy Image model首先，我们需要构建一个雾天图像的模型。公式如下所示，其中I表示雾天图像，J表示没有雾的图像，t表示空气穿透率，A表示纯雾。式子中的x均表示为图像中的像素点。 上式非常容易理解：我们最终看到的雾天图像是由透过空气传递过来的原始景观图像和一定浓度的雾叠加而成。 而作为去雾，我们是要依据已有的雾天图像I来得到原始的景观图像J，这就需要利用暗通道原理来求得模型中的空气穿透率t。 暗通道基于观察，何凯明博士提出了这样的假设：自然界中的大部分非天空物体，其rgb三个颜色通道中至少有一个值非常低，其表达式如下所示： 其中Ω为x*x的像素方块。 下图是先取图像中三个通道的最小值构成一张灰度图，然后在做一个一定窗口大小的最小值滤波，最终得到暗通道处理图。 通过处理图片我们可以清晰看出，除了白色的部分（三通道的值都比较大），其余部分的暗通道值很小，近似符合暗通道趋向0的假设。 去雾模型推导对于雾天模型的公式，我们现在做如下处理： 为了得到最终的去雾图像，我们需要求得t和A。推导过程如下所示： 由于即便在正常的天气中，原始景观传过来的时候也是经过了一定浓度的大气（可以认为是雾）。而对于参数A，我们是这样计算的：选取一定区域内亮度最大的值作为A（理论上认为纯雾接近纯白）这样就将t和A的值分别求了出来，从而得到去雾后的图像J。 采用这样的方法得到的图像如下所示： 由于在图像处理的过程中都不是基于一个像素而是一个像素集合的方块进行的，所以实际得到的图像中物体边缘会有比较明显的白边的存在，而对于这种现象，何凯明博士先后提出了两种理论予以解决。 去除伪影Soft Matting 2009该方法较为复杂，且处理较慢，早已不用，本文不做赘述 Guided Filter 导向滤波 2011导向滤波先做了一个如下的先验假设：所有邻近的点之间都是线性的，同时任何方程在局部的小段都可以认为是线性的。 经过推导可得： 其中q为输出图像，I为输入图像，p为滤波图像。i和k都是像素index，a和b是线性参数。在导向滤波中，I可以为任何导向图像 上述式子的一大优点就是其可以保护边界值。 通过上述式子我们可知，当像素强度变化不大时，a趋向于0而b等同于窗口的均值强度。等同于做一个均值滤波。 而当强度变化大时，a趋向于1而b趋向于0。等同于不做滤波，保留边界。 对之前的两张图片进行导向滤波处理，我们可以得到较好的结果。 总结最后我将展示一些去雾的效果： 去雾算法在处理非天空的自然物体时效果很好。如图： 同时在处理城市建筑时也有着不俗的表现。如图： 但是同时其也有着一些不足之处 比如在处理以白色物体为背景的图像时，会出现去雾效果不好以及色彩偏蓝的现象。这主要是因为去雾算法是基于暗通道值趋向为0的先验假设，而白色背景是不符合这种先验假设的，由于不符合物理模型所以才导致出错。如图： 此外当雾太厚的时候，还会出现过曝的情况，这是由于穿透参数t很小，根据之前的推导，我们会得到一个较大的J(x)。这才导致了过曝的现象。如图： 所以总而言之，去雾算法可以取得一个比较好的效果，不过也有其一定的局限性，要视具体的情况而定。 想要上手参考的，详见我的github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[First Article]]></title>
      <url>%2F2016%2F11%2F23%2FFirst-Article%2F</url>
      <content type="text"><![CDATA[浮生偷得几日闲，遂作此blog，望与有志者相识于此。 What will be in this blog技术文作为一名计算机专业的学生，开此blog的初衷自然是强化学习的动力，促进自己去研究前沿的知识，并以博文的形式与大家共享。 随笔“意皆有所郁结，不得通其道，故述往事,思来者”，自古这就是知识分子的通病，想来我也不能例外。在本blog中，我也会时不时将自己的所想所感放上来，权当一种情绪宣泄的途径，让各位见笑。 游记二十余载间也游历了不少大好河山，附上游记既可为诸位提供行程指导，同时也为了加深这些美好的印象。 趣谈Why so serious!? Let’s have some fun. What won’t be in this blog负能量正如我们使用Python的理由——“life is short”，何苦牢骚满腹呢。虽说是情绪的宣泄，也只是抒发人生的思考，给出自己的见解，绝非自怨自艾，叹命途多舛，哀人生不公。]]></content>
    </entry>

    
  
  
</search>
