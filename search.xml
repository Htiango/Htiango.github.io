<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[012 Integer to Roman]]></title>
      <url>%2F2017%2F01%2F19%2FLeetcode-012%2F</url>
      <content type="text"><![CDATA[Leetcode 012，关于数字转罗马数相关处理。 题目Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 解题思路对于这道题而言，难度主要是在对罗马数的理解上，可以通过查阅wiki得到。再从较大的罗马数开始进行逐步判断。 具体代码见下，总运行时间为32ms 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public: string intToRoman(int num) &#123; vector&lt;char&gt; vec; int temp = num; while(temp - 1000 &gt;= 0)&#123; vec.push_back('M'); temp -= 1000; &#125; if(1000 - temp &lt;= 100)&#123; vec.push_back('C'); vec.push_back('M'); temp -= 900; &#125; if(temp - 500 &gt;= 0)&#123; vec.push_back('D'); temp -= 500; &#125; if(500 - temp &lt;= 100)&#123; vec.push_back('C'); vec.push_back('D'); temp -= 400; &#125; while(temp - 100 &gt;= 0)&#123; vec.push_back('C'); temp -= 100; &#125; if(100 - temp &lt;= 10)&#123; vec.push_back('X'); vec.push_back('C'); temp -= 90; &#125; if(temp - 50 &gt;= 0)&#123; vec.push_back('L'); temp -= 50; &#125; if(50 - temp &lt;= 10)&#123; vec.push_back('X'); vec.push_back('L'); temp -= 40; &#125; while(temp - 10 &gt;= 0)&#123; vec.push_back('X'); temp -= 10; &#125; if(10 - temp &lt;= 1)&#123; vec.push_back('I'); vec.push_back('X'); temp -= 9; &#125; if(temp - 5 &gt;= 0)&#123; vec.push_back('V'); temp -= 5; &#125; if(5 - temp &lt;= 1)&#123; vec.push_back('I'); vec.push_back('V'); temp -= 4; &#125; while(temp - 1 &gt;= 0)&#123; vec.push_back('I'); temp -= 1; &#125; string str(vec.begin(), vec.end()); return str; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[011 Container With Most Water]]></title>
      <url>%2F2017%2F01%2F19%2FLeetcode-011%2F</url>
      <content type="text"><![CDATA[Leetcode 011，关于数字数组的相关处理。 题目Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 解题思路Brute force拿到这道题我的第一个想法就是用两重循环来暴力求得答案，很遗憾这种方法最终以超时告终。在此不做赘述，仅贴在此处以示警戒。 Two Pointers这道题比较好的一种方法就是采用两个指针分别从头从尾向中间逼近。 通过观察我们可以发现，当头尾指针分别在i和j处时（i&lt;j），若ai为较小的那个，则若我们将j向左移，则得到的值一定小于刚才的值，所以在这种情况下，我们将i向右移，保持j不变。若aj较小时以此类推。 这样我们就能仅以时间复杂度O(n)就得到了最大值。 详细代码见下，运行时间为19ms 123456789101112131415161718192021class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int length = height.size(); int size = 0, max_s = 0; int start_index = 0, end_index = length - 1; while(start_index &lt; end_index)&#123; if(height[start_index] &lt; height[end_index])&#123; size = height[start_index] * (end_index - start_index); start_index++; &#125; else&#123; size = height[end_index] * (end_index - start_index); end_index--; &#125; if(size &gt; max_s) max_s = size; &#125; return max_s; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[巨人的陨落]]></title>
      <url>%2F2017%2F01%2F18%2F%E3%80%8A%E5%B7%A8%E4%BA%BA%E7%9A%84%E9%99%A8%E8%90%BD%E3%80%8B%2F</url>
      <content type="text"><![CDATA[都说历史是一个任人打扮的小姑娘，可架不住看客犀利的目光。从没有一段“淡妆浓抹总相宜”，浓妆艳抹和略施粉黛间的取舍全仗笔者的底蕴。 抽空拜读了肯·福莱特世纪三部曲之一的《巨人的陨落》，深有感触。其通过POV方式的以小见大，带我领略了一战前后的英德法俄美。从大国外交到战争，从权贵达官到平民百姓，书中从一位位主人公的视角出发，勾勒出了一段段充满感情的鲜活历史。 简介全书以4个国家中的5个家族为线索（俄国的别斯科夫、英国的菲兹赫伯特和威廉姆斯、德国的冯·乌尔里希、美国的杜瓦），通过第一人称POV手法，详细介绍了各自国家在一战前后的各种状况。 作者巧妙地将这5个家族定位在不同的阶级上，既有传统贵族的菲兹赫伯特与冯乌尔里希家族，也有新兴的杜瓦家族，同时还有工人阶级的威廉姆斯家族以及代表着传统俄国农民在变革时代间变迁的别斯科夫家族。 正是这巧妙的定位，使得我们得以如亲历般见证着： 一战爆发前英德法俄奥之间的外交对话。个人对这段格外着迷，以一个个国家精英的视角生动展现了国家政治外交上的隐忍与取舍。 一战中贵族的军官视角，平民的战士视角。正是一战加速了欧洲大陆传统贵族的没落。 俄国二月革命、十月革命的萌芽与诞生（列宁的归来） 战后协约国间形如分赃般的丑恶嘴脸，以及战后德国的糟糕境地。 本书以 Fall of Giants 为名，以一 fall 表示了欧洲大陆经过一战后的由盛转衰，同时还意味着战后的欧洲传统贵族开始走向了没落，战时战后尤以英国为主的妇女平权运动打破了以往男盛女衰的格局。 最令我感到惊讶的是作者写在文后的那句话 我的原则是：要么某一场景真实发生过，或者有可能发生；要么某些话真正说过，或者有可能说。如果我发现有某种原因让某种场景不可能真正发生，或不可能说出某些话——例如某个人物当时处于另一个国家，我便将其略去。 我想，这或许就是读完全文如此舒畅的原因了吧。 Thoughts如果说要让我从整本书中选出最有感触的一段，我想就要数关于俄国革命的部分了。 书中一段格雷戈里的内心活动一下子就抓住了我的心 一个孩子的成长就像一场革命，格雷戈里心想，你可以让他诞生，但后来如何就全然不在你的掌控之下了。 不像我国媒体般吹嘘十月（二月）革命的伟大，也不同西方媒体般对苏维埃敬而远之，书中以及其克制的手法，分别从俄国国内贵族和平民，以及英国贵族与平民的角度，多方面阐述了对革命的看法。 有沙皇治下的市民吃不上面包，有警察枪击手无寸铁的游行群众，也有革命之时大街上的打砸抢烧；有贵族不经审判绞死“侵占”自家空闲领地的农民，有军官贪污军需置士兵的死活与不顾，也有革命成功后苏维埃政权向贫穷农户强征口粮甚至枪毙不配合者。 的确，革命势在必行，但是在打破旧制度制定新制度的过程中，又有谁能确保自己不会成为那些打败恶龙最终成为恶龙的勇士呢？苏维埃是少数敢于站出来挑战沙皇权威的政党，以反对对人民的压迫，还人民以土地作为党的纲领，但是执政后也强抢粮食并枪毙不肯交粮的农民，甚至枪毙倒向孟什维克党的工人。 或许恶龙和勇士就是一条莫比乌斯带，我们永远不知道究竟是那一面。 写在文后：上述感想只是单纯讨论苏维埃政权，请勿发散思维！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[010 Regular Expression Matching]]></title>
      <url>%2F2017%2F01%2F18%2FLeetcode-010%2F</url>
      <content type="text"><![CDATA[Leetcode 010，关于字符串匹配。 题目Implement regular expression matching with support for ‘.’ and ‘*’. 12345678910111213141516'.' Matches any single character.'*' Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch("aa","a") → falseisMatch("aa","aa") → trueisMatch("aaa","aa") → falseisMatch("aa", "a*") → trueisMatch("aa", ".*") → trueisMatch("ab", ".*") → trueisMatch("aab", "c*a*b") → true 解题思路这道题我感觉有一定难度，我采用了下面两种方法来解。 Recursion拿到这道题，我的第一个想法就是用递归的方法来解决。在进行递归之前，我需要先对字符串p进行一些处理。首先是将代表着重复的符号‘*’从字符串中取出，并在另一个int型数组中表示。若对应位置的数组值为-1，表示对应的字符串可以有重复或没有，为1则正常。 在此基础上构建递归函数，得到最终的结果。这里我的代码可能有些凌乱，进行了较多的判断，这些还需要改进，望见谅。 最终程序的运行时间是43ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class Solution &#123;public: bool isMatch(string s, string p) &#123; int length1 = s.length(); int length2 = p.length(); if(length1 == 0 &amp;&amp; length2 == 0) return true; vector&lt;char&gt; vec_s, vec_p; vector&lt;int&gt; vec_p_num; int i = 0, count = 0; while(i &lt; length1)&#123; count = 0; vec_s.push_back(s[i]); i += 1; &#125; i = 0; while(i &lt; length2)&#123; count = 0; vec_p.push_back(p[i]); i += 1; count += 1; if(i &lt; length2 &amp;&amp; p[i] == '*')&#123; count *= -1; i += 1; &#125; vec_p_num.push_back(count); &#125; return recursiveMatch(vec_s,vec_p,vec_p_num); &#125; bool recursiveMatch(vector&lt;char&gt; &amp;vec_s, vector&lt;char&gt; &amp;vec_p, vector&lt;int&gt; &amp;vec_p_num)&#123; vector&lt;char&gt; vec_s2, vec_p2; vector&lt;int&gt; vec_p_num2; int s_length = vec_s.size(); int p_length = vec_p.size(); int i = s_length - 1; int j = p_length - 1; if(i == 0 &amp;&amp; j == 0)&#123; if(vec_s[i] != vec_p[j] &amp;&amp; vec_p[j] != '.') return false; return true; &#125; if(j &lt; 0)&#123; return false; &#125; if(i &lt; 0)&#123; if(j &gt; 0)&#123; if(vec_p_num[j] != -1) return false; vec_p.pop_back(); vec_p_num.pop_back(); return recursiveMatch(vec_s,vec_p,vec_p_num); &#125; if(j == 0)&#123; if(vec_p_num[j] != -1) return false; return true; &#125; &#125; if (vec_s[i] == vec_p[j])&#123; if(vec_p_num[j] &gt; 0)&#123; vec_s.pop_back(); vec_p.pop_back(); vec_p_num.pop_back(); &#125; else&#123; vec_s2 = vec_s; vec_p2 = vec_p; vec_p_num2 = vec_p_num; vec_s.pop_back(); vec_p.pop_back(); vec_p_num.pop_back(); return recursiveMatch(vec_s2,vec_p,vec_p_num) || recursiveMatch(vec_s, vec_p2, vec_p_num2); &#125; &#125; else if(vec_p[j] != '.')&#123; if(vec_p_num[j] != -1) return false; else&#123; vec_p.pop_back(); vec_p_num.pop_back(); &#125; &#125; // here vec_p[j] == '.' else&#123; if(vec_p_num[j] &gt; 0)&#123; vec_s.pop_back(); vec_p.pop_back(); vec_p_num.pop_back(); &#125; // here vec_p_num[j] &lt; 0 else&#123; vec_s2 = vec_s; vec_p2 = vec_p; vec_p_num2 = vec_p_num; vec_s.pop_back(); vec_p.pop_back(); vec_p_num.pop_back(); return recursiveMatch(vec_s2,vec_p,vec_p_num) || recursiveMatch(vec_s, vec_p2, vec_p_num2); &#125; &#125; return recursiveMatch(vec_s,vec_p,vec_p_num); &#125;&#125;; Dynamic Programming对于本题而言，最好的方法是dp法的backtracing。 对于数组dp[j][k]而言，其表示的是字符串s前j个和字符串p前k个是否match。其可以从以下三处得到： dp[j - 1][k]：若match，则需要确定p[k - 1]是可以重复的，且与s[j - 1]match dp[j][k - 1]：若match，则需要确定p[k - 1]是可以省略的 dp[j - 1][k - 1]：若match，则需要确定s[j - 1]与p[k - 1]彼此match。 代码见下，运行时间为9ms，较之recursion方法性能得以大大提升。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: bool isMatch(string s, string p) &#123; int length1 = s.length(); int length2 = p.length(); if(length1 == 0 &amp;&amp; length2 == 0) return true; vector&lt;char&gt; vec_s, vec_p; vector&lt;int&gt; vec_p_num; int i = 0, count = 0; while(i &lt; length1)&#123; vec_s.push_back(s[i]); i += 1; &#125; i = 0; while(i &lt; length2)&#123; count = 0; vec_p.push_back(p[i]); i += 1; count += 1; if(i &lt; length2 &amp;&amp; p[i] == '*')&#123; count *= -1; i += 1; &#125; vec_p_num.push_back(count); &#125; length2 = vec_p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(length1 + 1, vector&lt;bool&gt;(length2 + 1, false)); for(int j = 0; j &lt;= length1; j++)&#123; for(int k = 0; k &lt;= length2; k++)&#123; if(j == 0)&#123; if(k == 0) dp[j][k] = true; else dp[j][k] = ((dp[j][k - 1]) &amp;&amp; (vec_p_num[k - 1] == -1)); &#125; else if(k == 0)&#123; dp[j][k] = false; &#125; else&#123; dp[j][k] = ((dp[j][k - 1]) &amp;&amp; (vec_p_num[k - 1] == -1)) || ((dp[j - 1][k]) &amp;&amp; ((vec_p_num[k - 1] == -1)) &amp;&amp; (((vec_s[j - 1] == vec_p[k - 1])) || vec_p[k - 1] == '.')) || (dp[j - 1][k - 1] &amp;&amp; (((vec_s[j - 1] == vec_p[k - 1])) || vec_p[k - 1] == '.')); &#125; &#125; &#125; return dp[length1][length2]; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[009 Palindrome Number]]></title>
      <url>%2F2017%2F01%2F17%2FLeetcode-009%2F</url>
      <content type="text"><![CDATA[Leetcode 009，判断数字是否是回文数。 题目Determine whether an integer is a palindrome. Do this without extra space. 解题思路将数字转成string来进行处理，需要注意的是任何的负数都不是回文数，因此在转换前可以先进行判断，若为负数直接返回false。具体代码详见下： 12345678910111213141516class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0) return false; char temp[64]; sprintf(temp, "%d", x); string s(temp); int length = s.length(); for(int i = 0; i &lt; length / 2; i++)&#123; if(s[i] != s[length - 1 - i]) return false; &#125; return true; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[008 String to Integer (atoi)]]></title>
      <url>%2F2017%2F01%2F16%2FLeetcode-008%2F</url>
      <content type="text"><![CDATA[Leetcode 008，关于字符串转数字相关处理。 题目Implement atoi to convert a string to an integer. RequirementThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 解题思路做本道题的时候，我事先并没有参考题目中给出的对应要求，先尝试着自己进行试验得到结果。 具体的思路还是顺序遍历这个字符串得到最终的结果。 相关细节可以直接参考上述的requirement。 具体代码见下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: int myAtoi(string str) &#123; bool positive = true; int length = str.length(); int num = 0; bool first = true; bool figure = true; for(int i = 0; i &lt; length; i++)&#123; if(str[i]== ' ' &amp;&amp; first &amp;&amp; figure) continue; if(str[i] == '-' &amp;&amp; first &amp;&amp; figure)&#123; positive = false; figure = false; continue; &#125; if(str[i] == '+' &amp;&amp; first &amp;&amp; figure)&#123; positive = true; figure = false; continue; &#125; if(str[i] &lt; '0' || str[i] &gt; '9')&#123; if (first)&#123; return 0; &#125; break; &#125; if(first)&#123; first = false; &#125; if(INT_MAX / 10 &lt; num)&#123; if(positive) return INT_MAX; else return INT_MIN; break; &#125; num *= 10; if(INT_MAX - (str[i] - '0') &lt; num)&#123; if(positive) return INT_MAX; else return INT_MIN; break; &#125; num += str[i] - '0'; &#125; if(positive) return num; else return num * -1; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[007 Reverse Integer]]></title>
      <url>%2F2017%2F01%2F16%2FLeetcode-007%2F</url>
      <content type="text"><![CDATA[Leetcode 007，关于数字取反相关处理。 题目Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 解题思路方法很简单，即用循环取余的方法，在此不作赘述。这里唯一需要注意的是当转换后的数字超出int的范围时要返回0，所以需要在循环中进行判断。 1234567891011121314151617181920class Solution &#123;public: int reverse(int x) &#123; int result = 0, temp = 1; if(x &lt; 0)&#123; x = abs(x); temp = -1; &#125; while(x != 0)&#123; if(INT_MAX / 10 &lt; result) return 0; result *= 10; if(INT_MAX - (x % 10) &lt; result) return 0; result += x % 10; x /= 10; &#125; return temp * result; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[006 ZigZag Conversion]]></title>
      <url>%2F2017%2F01%2F16%2FLeetcode-006%2F</url>
      <content type="text"><![CDATA[Leetcode 006，关于字符串和数组的相关处理。 题目The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) &lt; P A H N &lt; A P L S I I G &lt; Y I R And then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows: &lt; string convert(string text, int nRows); convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. 解题思路对于这道题，我的思路是先确定列数，再用行、列得到最终的字符串。 具体代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string convert(string s, int numRows) &#123; vector&lt;char&gt; vec; int length = s.length(); int column = 0, columnN = 0, columnRemainder = 0, index = 0; if (numRows == 1) return s; else&#123; columnN = length / (2 * numRows - 2); columnRemainder = length % (2 * numRows - 2); if(!columnRemainder) column = 2 * columnN; else column = columnN * 2 + (columnRemainder - 1) / numRows + 1; &#125; for(int i = 0; i &lt; numRows; i++)&#123; for(int j = 0; j &lt; column; j++)&#123; if (i == 0 || (i == (numRows - 1)))&#123; if(j % 2) continue; index = (2 * numRows - 2) * (j / 2) + i; &#125; else&#123; if(!(j % 2)) index = (2 * numRows - 2) * (j / 2) + i; else index = (2 * numRows - 2) * (j / 2) + 2 * numRows - 2 - i; &#125; if(index &lt; length) vec.push_back(s[index]); &#125; &#125; string str(vec.begin(), vec.end()); return str; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[004 Median of Two Sorted Arrays]]></title>
      <url>%2F2017%2F01%2F13%2FLeetcode-004%2F</url>
      <content type="text"><![CDATA[Leetcode 004，关于array相关处理。 题目There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 即找出两组按大小排列的数组的中位数。 解题思路由于两个数组都是按好大小排列好的sorted array，所以我的思路是每次pop出两个数组中最大的那个，最终得到想要的中位数。 具体代码见下，最后的运行时间为32ms，高于85%的答案，比较满意。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int size1 = nums1.size(), size2 = nums2.size(); bool odd = (bool)((size1 + size2) % 2); int count = 0; int tempNum = 0; int lastTempNum = 0; int countLimit = (size1 + size2) / 2 + 1; while(count &lt; countLimit)&#123; lastTempNum = tempNum; count ++; if (size1 == 0)&#123; if(size2 == 0)&#123; return NULL; &#125; size2--; tempNum = nums2.back(); nums2.pop_back(); continue; &#125; else if(size2 == 0)&#123; size1--; tempNum = nums1.back(); nums1.pop_back(); continue; &#125; if(nums1[size1 - 1] &gt; nums2[size2 - 1])&#123; size1--; tempNum = nums1.back(); nums1.pop_back(); &#125; else&#123; size2--; tempNum = nums2.back(); nums2.pop_back(); &#125; &#125; if (odd)&#123; return tempNum; &#125; else&#123; return 0.5 * (tempNum + lastTempNum); &#125; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[005 Longest Palindromic Substring]]></title>
      <url>%2F2017%2F01%2F12%2FLeetcode-005%2F</url>
      <content type="text"><![CDATA[Leetcode 005，关于回文和字符串相关处理。 题目Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 即找出字符串中的最大回文子集。 解题思路本题的核心在于字符串的相关处理。我的思路主要是确定子集中的最大长度和起始位置。这里主要展示我采用的两种方法。同时介绍题目推荐的方法。 brute-force一开始我用了比较笨的 brute-force 的方法。这种方法的时间复杂度为 N^3，在此不作推荐。 这种方法是从字符串的一头一尾开始搜索，一旦有相同的符号则进行下一步判断，判断再往里的两个字符是否相同，如果相同则进行下一步的判断。 这种方法最不好的地方在于进入循环判断的不一定是回文，很有可能出现靠近两边的部分回文但是中间部分不形成回文，这会浪费大量的运算资源而最终得不到一个回文数。 不过，最后这种方法还是可以通过测试，不过运算的时间有736ms之多。效果不好，在此仅作反面参考。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: string longestPalindrome(string s) &#123; int maxLength = 1, startIndex = 0, endIndex = 0, tempLength = 0; int length = s.length(); for(int i = 0; i &lt; length; i ++)&#123; for(int j = length - 1; j &gt; i; j--)&#123; if(s[i] == s[j])&#123; bool judge = false; tempLength = j - i + 1; if(tempLength &lt; 4)&#123; if(maxLength &lt; tempLength)&#123; maxLength = tempLength; startIndex = i; endIndex = j; &#125; judge = true; &#125; else&#123; bool ifBreak = false; for(int k = 1; k &lt; (tempLength / 2); k++)&#123; if(s[i + k] != s[j - k])&#123; ifBreak = true; break; &#125; &#125; if(!ifBreak)&#123; if(maxLength &lt; tempLength)&#123; maxLength = tempLength; startIndex = i; endIndex = j; &#125; judge = true; &#125; &#125; if(judge)&#123; break; &#125; &#125; &#125; &#125; return s.substr(startIndex, maxPalinLength); &#125;&#125;; 中心拓展上述的方法不是非常成功的基础上，我进一步思考，有没有办法可以使得我们只对回文数进行判断，这样就不会将宝贵的计算资源浪费在非回文数上，能够大大提高计算的效率。 为此，我想的方法是以字符串中的某一字符为中心，展开为一个回文数。这样不仅能够保证每个展开的都是回文数，同时还将时间复杂度降到了 N^2。 在这种方法中，我将奇数长度的回文数和偶数长度的回文数分别进行判断处理，这样也大大提高了运算的效率。 这种中心拓展的方法最后的运算时间为39ms，效果还算理想，不过离采用dp法还是有一定的差距。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: string longestPalindrome(string s) &#123; int length = s.length(); int startIndex = 0, tempLength = 0, maxPalinLength = 0; for (int i = 0; i &lt; length; i++) &#123; int length1 = i, length2 = length - i - 1; int maxLength = (length1 &gt;= length2) ? length2:length1; bool oddBreak = false, evenBreak = false; for (int j = 0; j &lt; maxLength + 1; j++)&#123; if (i == length - 1)&#123; evenBreak = true; &#125; if (!oddBreak)&#123; if (s[i - j] == s[i + j])&#123; tempLength = 2 * j + 1; if (tempLength &gt; maxPalinLength)&#123; maxPalinLength = tempLength; startIndex = i - j; &#125; &#125; else oddBreak = true; &#125; if (!evenBreak)&#123; if (s[i - j] == s[i + 1 + j])&#123; tempLength = 2 * j + 2; if (tempLength &gt; maxPalinLength)&#123; maxPalinLength = tempLength; startIndex = i - j; &#125; &#125; else evenBreak = true; &#125; if (evenBreak &amp;&amp; oddBreak)&#123; break; &#125; &#125; &#125; return s.substr(startIndex, maxPalinLength); &#125;&#125;; Dynamic Programming对于这道题而言，也可以用动态规划的方法进行。 我们知道，对于一个回文数而言，夹在其中间的那个子集一定是回文数。所以我们可以用一个二维的矩阵来判断字符串的一段子集是否是回文数。比如P[2][4]表示的就是字符串中以index 2为始，以index 4为结束的子集，若是回文数，则在进行P[1][5]判断的时候，只需直接判断s(1)是否等于s(5)即可。这样可以大大减少运算的时间。 不过最后的运行时间为202ms，不如方法二有效率。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: string longestPalindrome(string s) &#123; int length = s.length(); int Pa[length][length]; memset(Pa, 0, length*length*sizeof(int)); int maxLength=0, startIndex = 0, tempLength = 0; for (int i = 0; i &lt; length; i++)&#123; for (int j = 0; j &lt;= i; j++)&#123; if (j == i)&#123; Pa[j][i] = 1; &#125; else&#123; if(s[i] == s[j])&#123; if (i - j == 1)&#123; Pa[j][i] = 1; &#125; else&#123; if (Pa[j + 1][i - 1] == 1)&#123; Pa[j][i] = 1; &#125; &#125; &#125; &#125; if (Pa[j][i] == 1)&#123; tempLength = i - j + 1; if (tempLength &gt; maxLength)&#123; startIndex = j; maxLength = tempLength; &#125; &#125; &#125; &#125; return s.substr(startIndex, maxLength); &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Head First Civilization V]]></title>
      <url>%2F2017%2F01%2F09%2FCivilization-V%2F</url>
      <content type="text"><![CDATA[开篇让我们将地球的时钟拨到远古世纪，蜿蜒的河流边正孕育着文明的曙光，一队队移民正取下行装，准备在历史的长河中书写壮丽的篇章。一座座简陋的城市如雨后春笋般拔地而起，勾勒着美好的希望。手持木棒的勇士正开疆拓土，怀揣着一统天下的梦想。 上述这些画面描述的就是文明系列游戏的开场。一把文明游戏就仿佛是人类文明盛衰兴亡的缩影，带给我的感触绝非是一般游戏可比拟的。一句话，文明系列，不仅仅是游戏。 如果说有什么游戏值得我整整一天宅在电脑前废寝忘食，那一定是席大大的文明系列。而在6代bug不断，4代画质感人的今日，5代的美丽新世界显得格外诱人，在一个又一个“next turn”的指引下，一切都如白驹过隙，一晃而逝。（友情提示，没有闹钟的，没有自制力的，请远离文明系列） 宏观看文明虽然不像P社四萌那样有着极高的历史还原度，但是在宏观层面上对人类文明的量化和物化我从未见过如文明这般卓越的。它将人类文明的核心量化为科技和文化，而各个国家的实力物化为一个个城市以及单位，彼此之间相互影响，构成了整个复杂交错的文明世界，也让玩家看到了数千年来人类文明发展的缩影，闲暇之余颇有感触。 科技与文化在Civilization这系列游戏中，人类文明时刻被文化和科技点数推进着前行。随着科技的飞速发展，科技树茁壮成长着，一个个闻所未闻的建筑和单位出现在了城市的建设列表中，等待着一国之主的召唤。它们将进一步促进科技和文化的发展。而随着文化的积累，一项项政策被从上锁的黑箱拿上了台面，如同现在的城市规划和国家方针一样，指引着帝国步入黄金时代，迈入胜利的殿堂。 的确，人类的文明从来都是一个厚积而薄发的过程，没有前期挖石头的技术，哪来之后的石油、煤矿等的大发现？没有律法的出现，哪来的意识形态的选择？纵使给远古时代的人民一百个爱因斯坦，也注定不会有相对论和量子力学的丁点萌芽。这也是为什么，在游戏中，政策的选择局限于时代，科技的研发取决于之前的积累。 城市与单位玩家通过建造城市设施和调整市民工作来实现一个城市在粮食、产能、金钱、文化和信仰等方面的平衡，使之为帝国的发展贡献力量。每每在进入城市界面时，我的脑海中浮现的不是一个个单调的数字或是乏味的图标，而是一个个活生生的市民为了生计在城市之郊辛勤工作，为城市的产能和产粮做出微不足道的贡献。这样的生化当然难言快乐，尤其是当城市人口急剧膨胀之际，辛勤劳作了一天的市民不得不蜷曲在狭小的住处休息，这也是为什么在游戏中人口和城市数量的增长会带来大幅的不快乐。于国家而言，哪里有城市，哪里就有剥削，除非危及自身统治，人民的快乐不足为道，这又何尝不是现实生活的一个缩影呢？通过产出奢侈品和建设娱乐设施，市民们的快乐可以得到大幅提升，似乎被剥削的不快早已被抛之脑后，看来娱乐至死的年代由来已久啊。 如果说用一句话总结文明系列的精髓，那就是国家的利益高于一切。在游戏界面中，渺渺众生不过是一串串简单的数字，一队队忠义无双的士兵，一个个任劳任怨的劳工。他们在玩家的带领下，为着最终的胜利默默奉献着自己。游戏中，为了保住珍贵的笑脸，我们往往不惜将攻占的城市付之一炬，看着城市的人口一回合一回合地下降，直至城池变为废墟。为了省下足够的金钱，我们往往会将多余的单位就地处决，看着他们化作一道光永远消逝在历史的长河中。为了抢在AI之前造出奇观，我们往往会强制让市民忍饥挨饿，没日没夜地为产能贡献力量。沉浸在游戏中的我们又怎会意识到呢，这些不就是曾经的“嘉定三屠”，“扬州十日”，“长平之战”后的白起杀降，布尔什维克在战后依然实施的“战时共产主义”？ 唯一带点个人色彩的也就是在城市中产出的伟人了，他们有着与真实历史中某位名人相同的名字，而在游戏中他们的命运也不外乎是为了一项奇观、一项科技、一个作品或是一场战役，鞠躬尽瘁死而后已。可即便如此，他们还是一个个义无反顾地诞生于城市，为了帝国的繁荣昌盛前赴后继。真可谓是“苟利国家生死以，岂因祸福避趋之”。 国家和城邦文明系列游戏经久不息的一个原因，就在于多样的文明种类。玩家可以从二三十个文明中挑选一个进行游戏，而这二三十个文明也都各具特色。好玩的一点在于，游戏选取这些文明中的一位著名统治者，将其作为游戏中该文明的领袖。所以在游戏界面中，我们得以看这样的场景，骑在马上的拿破仑不屑地评论着我羸弱的士兵，白宫中的华盛顿义正言辞地进行抗议，雍容华贵的武则天不怒自威地否决了我的交易。正是这些文明领袖们将我们更好地带入了游戏中，将复杂难表的国家关系用领袖们的喜怒哀乐鲜活地呈现给了玩家。 在文明游戏中，国家关系是一个很重要的部分。两国间的良好关系是进行合作研究以及现金交易的前提。同时两国间的贸易也必须在非战争状态的条件下才能进行。这不就是现实的一个缩影吗？ 除了国家之外，在游戏中玩家还会碰到许多城邦，也就是现实中的“小国”。在第一次遇到时它们会给你一些钱，我总是开玩笑地说这是供奉给大国的礼金，摆出低调的姿态祈求乱世中的苟存。刚玩的时候我总是对这些城邦不屑一顾，对这些蝼蚁一直提出的烦人任务不理不睬。看着它们一个个成为了其他国家的盟友，想着这些小国送给你们也没什么用处，就这样一直开开心心地在家种田。一转眼国际形势骤变，昔日笑脸相迎的对手最终兵戎详见，我惊讶地发现那些城邦也都紧跟着它们主子的步伐，争先恐后地对我宣战。我当时第一个想到的不是打开存档，而是“这不就是北约？”。玩得越多，我越觉得城邦好处大大的，盟友会给你兵，给你文化，给你粮食，给你资源，给你信仰，还能给你快乐！而如果觉得完成城邦任务太麻烦，大可以拿钱砸，一堆堆金子砸在城邦的脸上，玩家就能享受到如同城邦爸爸一般的待遇，给吃给喝还能帮打架。 可以说文明中对国家和城邦的设定很好地诠释出了大国与小国间的外交政策与外交姿态。 胜利种类在Civilization V这款游戏中，总共有5种胜利的方式，而这5种方式也给玩家以不同的感悟。 外交胜利有人说，联合国建立的意义是为了让全世界更好地按照大国意志来运转，而事实也确有几分相似。诸如伊拉克战争、古巴禁运等事件就是大国通过对联合国的控制来实现对小国的支配，从而更好地实现自身利益。在文明游戏中也是亦然，一旦世界议会选出了世界领袖，那么也就意味着该国有着将自己的意志以世界议会中某一议题的形式强加于他国的能力，也就实现了外交上的胜利。 征服胜利文明V这款游戏也被称为野蛮V，不打仗怎么赢天下。一个无论科技和文化都远远落后的文明要想赢得游戏，只有用武力打破现有的状态。一旦取得了所有文明的首都，就取得了征服胜利。 作为一名爱好和平的种田流玩家，从个人理念出发我是十分不喜欢玩征服胜利的，一个原因自然是因为操纵“百万大军”攻城下寨是一件极其繁琐的事。还有一个很重要的原因是我在游戏过程中探索出来的：在飞船起飞前的一回合，我抱着玩一玩的心态将我的“小男孩一号”原子弹投向了身边的埃及，瞬间一座人口30+的主城血条只剩下了一半左右，周边的单位也是死伤惨重，城市中隐约还有人群大喊哭泣的声音，虽然知道这不过是游戏一场，但是内心总感觉有些堵。当然啦，打仗是一定要打的，不过我更喜欢逼得对面割地赔款，然后我在安安心心发战争财。 科技胜利从仰望星空开始的不仅仅有哲学，还有科学！将人类文明传播到更为浩瀚的宇宙一直是科学家们的梦想，也支撑着他们燃烧自己，成就科学的跃进。当飞船起飞的一刹那，人类文明的种子已播撒在银河系中，承载着无数人的梦想驶向远方。这也是我最喜欢的胜利模式！ 文化胜利当玩家的文化支配了其他文明，当那里的人民都穿着我们的衣服，说着我们的语言的时候，我们还能说这是别的国家吗？文化胜利的本质就是通过本国文化对他国潜移默化的影响，通过人民的融合实现国家的兼并。实现难度着实不小（一般都是打出来的。。。） 时间胜利（一般都关闭时间胜利）满满都是吐槽。。。在世界末日前的那一刻，上帝说，拯救那个分数最高的文明吧，于是就有了时间胜利。。。（2050年分数最高的玩家获胜） 结尾开了程序猿的脑洞写下了这篇civilization的Head First，文明带给我的不仅仅是绝佳的游戏体验，还让我有了很多思考，打算有时间出一篇Thinking in Civilization。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Concurrent Programming]]></title>
      <url>%2F2016%2F12%2F10%2Fconcurrent-programming%2F</url>
      <content type="text"><![CDATA[并发在应用程序中起着很重要的作用，本文将详细介绍应用级的并发 进程进程是构造并发程序最为简单的方法。在CSAPP的第八章中就已经介绍过：进程本质上就是一个执行中的程序的实例，每当我们运行一个程序的时候就会创建一个进程并在其上运行相关文件。而进程在真正运行的过程中并不是独占处理器的，根据不同的逻辑控制流（每个进程的PC值），不同的进程轮流使用处理器。如果不同的进程在运行过程中有时间的重叠，则两者之间是并发的关系。采用进程的并发方式可以在父子进程之间共享文件，同时两者不同的地址可以避免彼此信息的覆盖问题。但是这种方式不得不采用IPC（进程间通信）的方式来交换彼此的信息，而这是一种开销很大的方式，大大降低运行的速度。 I/O多路复用当我们在浏览一个网页的时候，服务器可以同时处理浏览器发送的请求和用户输入的指令，而这主要采用的就是I/O多路复用的方法。其核心思想就是采用select函数，要求内核挂起进程，仅当一个或多个I/O事件发生后才将其返回给应用程序。本质上这种方法下我们创建自己的逻辑流，利用I/O多路复用来进行流的调度。这种方法的一个最大的优点就是信息交换的便捷，共享数据来得更为高效(无需在流之间切换)，使我们对程序有着更好的掌控但是与此同时，与第一种方法相比，编码量的复杂度大大提升。而且一旦某一逻辑流在读某一文本，其他流就不能读了。这也是不是很高效的一点。 线程什么是线程与进程是运行在系统中的逻辑流对应的，线程是运行在进程中的逻辑流，每个线程都有着唯一的整数ID、栈指针、栈、计数器、寄存器等等，运行在一个进程中的线程共享该进程的整个虚拟地址空间。从本质上讲，这种方法更像是上述两种方法的结合。 线程是如何执行的所有的进程在最开始的时候都是单线程的，这个线程就是主线程。随后在某一时间点主线程会创建一个对等线程并与之一起并发运行（来回切换）由于线程的context对比进程而言要小得多，所以线程之间的切换也要快得多。主线程和对等线程之间基本上是相同的，都能读写相同的共享信息。 线程相关函数创建线程1234567#include &lt;pthread.h&gt; typedef void *(func)(void *);// Returns 0 if OK, nonzero on error int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg); // Returns thread ID of callerpthread_t pthread_self(void); 结束线程当调用下述函数时，主线程会等待所有对等线程终止时在终止自己和整个进程。否则则当线程运行完后隐式终止。 123// terminate threads#include &lt;pthread.h&gt; void pthread_exit(void *thread_return); 分离线程在线程被创建后，其默认是可结合的，即可以被其他线程回收杀死，而下面的函数则可以将其分离，仅当其终止时才自动释放存储。 123// detach threads#include &lt;pthread.h&gt; int pthread_detach(pthread_t tid); // Returns 0 if OK, nonzero on error 线程中同步变量各个线程彼此之间可以共享变量和文件，但是如果不加限制有时会造成同步错误。因此，在文件或是变量同步(读写)的过程中，并发的程序有着种种的限制。在本书讲pipeline的过程中就介绍过read after write的问题。在pipeline中如果先写后读则读的过程至少需要等待三个周期才能保证不出错（当然在forwarding的方法下我们可以将等待周期减为1个）。同样的，我们在并发线程中进行文件或是变量读写操作的时候，也会遇到类似的问题：如果在某一线程读取某一变量值的同时，另一线程正在对改写这一变量(这里的同时指的并不是完全意义上的同时，而是很短的时间)，由于读和写都要一定时间，这就可能会造成数据的错误。因此我们需要对线程间的变量同步加以限制。主要采用Posix中的 P 和 V 操作。 P(s)：加锁操作。若s非零则将其减1返回，否则挂起线程直至s非零。 V(s)：解锁操作。若有线程被P操作挂起则将s加1，重启该线程。 因此，我们可以通过 P 和 V 操作实现线程中的变量同步。以下代码展示了读者优先的线程，只要有一个读者在读，其他的读者就能忽略锁而毫无障碍的读取变量。 1234567891011121314151617181920212223// global variablesint readcnt;sem_t mutex, w;void reader(void)&#123; while(1)&#123; P(&amp;mutex); readcnt++; if (readcnt == 1) &#123; P(&amp;w); &#125; V(&amp;mutex); // do the reading P(&amp;mutex); if (readcnt == 0) &#123; V(&amp;w); &#125; V(&amp;mutex); &#125;&#125; 线程中的竞争问题如果我们在构建线程时，每次创建一个新的对等线程都是通过传递一个指向唯一整数ID的指针的话，很有可能会导致程序的错误，因为在这种情况下各个线程会产生竞争。而解决这种问题的方法也很简单，只需要用一个malloc函数为每个线程动态分配一个整数ID的指针，并将这个这个指针传递给构建线程的函数中。同时最后别忘了对指针进行free来避免memory leak。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[proxy-lab]]></title>
      <url>%2F2016%2F12%2F09%2Fproxy-lab%2F</url>
      <content type="text"><![CDATA[Proxy Lab 作为 cmu 18600 以及 15213 这两门课的最后一个lab，其综合性非常强。既需要掌握好 web programming 以及 concurrent programming 的相关知识，还需要结合之前涉及的 shell 和 cache 的相关操作。本文将详细介绍 proxy lab 的解题思路。 什么是proxy首先，我们需要知道什么是proxy？当我们平时打开浏览器的时候，输入一个URL，浏览器会向服务器发送相应的请求，服务器在接收到请求后会将相应的response发回给浏览器，如此循环往复从而加载完网页中的全部内容。此时所有的请求和响应之间的交流全是发生在 client (浏览器)和 server (服务器)之间的。而有时我们会在client和server之间添加代理，来进行相关的处理，这个代理就是实验要求我们完成的proxy。 proxy的大致示意图如下所示 实验准备在本次实验中，我们采用的浏览器是Firefox，设置代理的过程如下所示：打开设置中的高级，选择网络，点设置并按照如下设置（若proxy在本地则选择localhost或是127.0.0.1）需要注意的是，端口一定要和之后运行proxy时的端口一致 proxy如何处理request打开Firefox网页，Mac下alt + cmd + q，Win下按F12进行观察，点击每条可以显示出请求和响应的内容 通过这种方法，我们可以很轻松地看到请求和响应头。 而作为一个proxy，所需要做的事情主要有这么几件： 从请求中获取请求的方法，请求网址的hostname，path以及port（没有的话为80）(有多种方法解析，我采用的是正则表达式) 需要注意的是，本实验中不支持非get的方法，同时也不支持任何以HTTPS开头的网页请求。本实验中以501错误返回这类请求。 改变请求头中的一些内容（比如User-Agent，connection改为close） 添加 Proxy-Connection: close，来确定请求响应的交换是否结束 改变原先请求中的version。（从 HTTP/1.1 到HTTP/1.0） 对网页端发送请求进行修改之后，发送给服务器，再将response返回给网页端，如此循环往复直到网页内容加载完毕 处理多线程操作在完成上述内容之后，我们就实现了一个逐条处理网页端请求的proxy。但是在现实中这样的效率极其低下。所以对于我们的proxy还需要使其支持多线程操作。其所涉及的函数如下所示 1234int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);int pthread_detach(pthread_t thread); 其中pthread_create函数用于打开一个新的线程，通过调用start_routine这个函数，而其中的arg是start_routine函数的参数。特别要注意的是，arg一定要事先进行malloc，为每个线程ID分配一个独立的块，并将指向这个块的指针传给start_routine。不然线程会出现竞争问题导致错误。同时在结束线程时一定要释放这些块来避免memory leak（我就是在这里跪了很久的。。。） 而第二个函数是用于在线程中防止线程被其他线程回收或杀死。 在第一步中加入上述函数，基本上就能够实现proxy的多线程操作的部分。 存储网页内容以上的proxy已经基本完成了代理的要求。不过当我们重复请求某一个网址的时候，它还是要重新加载一遍，这就有点低效了。如果我们能够把之前网页端获取的响应存下来呢？这样当我们重复加载的时候就无需连接到服务器了。所以，我们还要让我们的proxy能够存储网页的内容。在本次实验中，我用一个类似于队列的双向链表来表示存储的cache。proxy在每次处理完网页端发来的请求后，先遍历整个链表，看是否有相同的request存在cache中，如果有就直接获取对应的response。没有的话就现将请求发动到server，将server返回的response写入到cache中。在具体的操作中，我采用的是FIFO，每次都将新的request/response加在链表的头。一旦cache存储已满，就从尾部pop。需要注意的是，一旦找到匹配的request之后，我们还需要将对应的node移到链表的头指针处。这样才符合FIFO。 上述就是我对与proxy lab的总结，希望大家都能做出一个完美的proxy！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[去雾算法浅析]]></title>
      <url>%2F2016%2F11%2F29%2F%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[何凯明博士在09年以 “Single Image Haze Removal Using Dark Channel Prior” 一文技惊四座。此文甚至成为09年的CVPR最佳论文。本篇博文将对这种去雾算法进行简要的分析，并通过自己的实现来更好的进行介绍。 算法核心介绍Foggy Image model首先，我们需要构建一个雾天图像的模型。公式如下所示，其中I表示雾天图像，J表示没有雾的图像，t表示空气穿透率，A表示纯雾。式子中的x均表示为图像中的像素点。 上式非常容易理解：我们最终看到的雾天图像是由透过空气传递过来的原始景观图像和一定浓度的雾叠加而成。 而作为去雾，我们是要依据已有的雾天图像I来得到原始的景观图像J，这就需要利用暗通道原理来求得模型中的空气穿透率t。 暗通道基于观察，何凯明博士提出了这样的假设：自然界中的大部分非天空物体，其rgb三个颜色通道中至少有一个值非常低，其表达式如下所示： 其中Ω为x*x的像素方块。 下图是先取图像中三个通道的最小值构成一张灰度图，然后在做一个一定窗口大小的最小值滤波，最终得到暗通道处理图。 通过处理图片我们可以清晰看出，除了白色的部分（三通道的值都比较大），其余部分的暗通道值很小，近似符合暗通道趋向0的假设。 去雾模型推导对于雾天模型的公式，我们现在做如下处理： 为了得到最终的去雾图像，我们需要求得t和A。推导过程如下所示： 由于即便在正常的天气中，原始景观传过来的时候也是经过了一定浓度的大气（可以认为是雾）。而对于参数A，我们是这样计算的：选取一定区域内亮度最大的值作为A（理论上认为纯雾接近纯白）这样就将t和A的值分别求了出来，从而得到去雾后的图像J。 采用这样的方法得到的图像如下所示： 由于在图像处理的过程中都不是基于一个像素而是一个像素集合的方块进行的，所以实际得到的图像中物体边缘会有比较明显的白边的存在，而对于这种现象，何凯明博士先后提出了两种理论予以解决。 去除伪影Soft Matting 2009该方法较为复杂，且处理较慢，早已不用，本文不做赘述 Guided Filter 导向滤波 2011导向滤波先做了一个如下的先验假设：所有邻近的点之间都是线性的，同时任何方程在局部的小段都可以认为是线性的。 经过推导可得： 其中q为输出图像，I为输入图像，p为滤波图像。i和k都是像素index，a和b是线性参数。在导向滤波中，I可以为任何导向图像 上述式子的一大优点就是其可以保护边界值。 通过上述式子我们可知，当像素强度变化不大时，a趋向于0而b等同于窗口的均值强度。等同于做一个均值滤波。 而当强度变化大时，a趋向于1而b趋向于0。等同于不做滤波，保留边界。 对之前的两张图片进行导向滤波处理，我们可以得到较好的结果。 总结最后我将展示一些去雾的效果： 去雾算法在处理非天空的自然物体时效果很好。如图： 同时在处理城市建筑时也有着不俗的表现。如图： 但是同时其也有着一些不足之处 比如在处理以白色物体为背景的图像时，会出现去雾效果不好以及色彩偏蓝的现象。这主要是因为去雾算法是基于暗通道值趋向为0的先验假设，而白色背景是不符合这种先验假设的，由于不符合物理模型所以才导致出错。如图： 此外当雾太厚的时候，还会出现过曝的情况，这是由于穿透参数t很小，根据之前的推导，我们会得到一个较大的J(x)。这才导致了过曝的现象。如图： 所以总而言之，去雾算法可以取得一个比较好的效果，不过也有其一定的局限性，要视具体的情况而定。 想要上手参考的，详见我的github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[First Article]]></title>
      <url>%2F2016%2F11%2F23%2FFirst-Article%2F</url>
      <content type="text"><![CDATA[浮生偷得几日闲，遂作此blog，望与有志者相识于此。 What will be in this blog技术文作为一名计算机专业的学生，开此blog的初衷自然是强化学习的动力，促进自己去研究前沿的知识，并以博文的形式与大家共享。 随笔“意皆有所郁结，不得通其道，故述往事,思来者”，自古这就是知识分子的通病，想来我也不能例外。在本blog中，我也会时不时将自己的所想所感放上来，权当一种情绪宣泄的途径，让各位见笑。 游记二十余载间也游历了不少大好河山，附上游记既可为诸位提供行程指导，同时也为了加深这些美好的印象。 趣谈Why so serious!? Let’s have some fun. What won’t be in this blog负能量正如我们使用Python的理由——“life is short”，何苦牢骚满腹呢。虽说是情绪的宣泄，也只是抒发人生的思考，给出自己的见解，绝非自怨自艾，叹命途多舛，哀人生不公。]]></content>
    </entry>

    
  
  
</search>
