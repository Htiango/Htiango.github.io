<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>你的朋友圈去哪里了</title>
    <url>/2020/03/07/%E4%BD%A0%E7%9A%84%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/</url>
    <content><![CDATA[<blockquote>
<p>成年人的悲欢并不相通，我只怕给人凭添聒噪。</p>
</blockquote>
<span id="more"></span>
<p>上月初寄回国的60只N95口罩还在途中，新冠病毒就已经在美国政府人民的“不懈努力”下开始了在湾区的表演。想必对于关注国内疫情的华人朋友来说，个中滋味更不好受。不知是福是祸，由于某位员工的原因，我司开启了一波WFH，至少对本周oncall的我来说，精神上得到了一定的放松，终于可以名正言顺 <s>from home not work</s>（并没有）<s>凌晨三点的page铃声也不再那么烦人了</s>（想多了）</p>
<p>有了些许闲暇，于是在<s>周六的早晨</s>随手翻看起了自己多年来的朋友圈，突然之间，对过去的自己有了一种陌生感。近六个月来的朋友圈总是阳春白雪，是我吗？是我，也不是我。过去的自己，总是会po一些生活的点滴，发一些尖锐的时评，夹杂着各种乱七八糟的后感和偶尔迸发出的中二气，看得我不禁开心地拍起了肚皮。是呀，多么美好的回忆呀！可是现在的我真的会在朋友圈发这样的东西吗？撇开政治不谈，我感觉自己已经越来越难以在展现真正的自我了，或许这就是步入了社会，这就是上了年纪吧。</p>
<p>细细想来：思想的碰撞，宜与友，不宜与众。在校园时，朋友圈或许还能称得上是朋友圈，而如今，更多的只能称之为交际圈。倘若不经意间展露的三观，引得一众评头论足，抑或有甚者妄加干预，如此种种，除了浪费时间，搞糟心情之外，更无一利。</p>
<p>初入社会的我或许心肠尚温，但似乎眼已冷，中二之气还在，但又囿于鄙人的眼色。于是乎意有所郁结，故述阳春白雪，谓之所思所感。</p>
<p>鲁迅先生曾说：</p>
<blockquote>
<p>人类的悲欢并不相通，我只是觉得他们吵闹</p>
</blockquote>
<p>如今的我，不敢如鲁迅先生般嫌弃他人吵闹，只是怕给人凭添聒噪罢了。</p>
<hr>
<p>【写在文后】：自诩不是一个多愁善感之人，或许近来偶觉孤单，略有感触。故写下不知所云之文，见笑！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>GraphQL Introduction</title>
    <url>/2019/11/12/GraphQL%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>有幸在工作中使用并熟悉了GraphQL，将在本文对其进行简要的介绍，并附上如何构建一个基于Django的GraphQL API 的 tutorial。</p>
<span id="more"></span>
<p>后端程序猿们都知道REST，这种API的定义方式一直广为流行。不过想必熟悉REST的朋友也知道，在REST下，每个接口对应着一个URL。随着接口的增多，URL的命名和维护的成本也逐步升高，而对文档的维护成本也很高。</p>
<p>熟悉Django的朋友想必也曾经历过维护REST API的痛苦，尤其是看着<code>urls.py</code>文件越来越长，文档更新速度永远赶不上需求的变动。</p>
<p>今年年初的时候，有幸全权负责一个internal website的后端部分，在和前端定义接口的时候，我们决定采用GraphQL而非REST。在整个项目进行的过程中，我深刻感受到了GraphQL带来的便利。当时也整理了不少相关的知识点(in English OF COURSE!)，懒得做翻译的我决定就直接把当时的笔记贴过来，希望能够有所帮助！</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>REST APIs requires loading from multiple URLs, while GraphQL APIs can get all the data your app needs in a single request.</p>
<p>There are multiple server libraries for GraphQL. And I mainly use the <code>Graphene</code>. And <code>graphene-django</code> is also a very good library binding with Django. </p>
<p>Though I haven’t tried its client libraries, but GraphQL does provide a bunch of client libraries. (It’s also very easy to implement since only involves HTTP requests)</p>
<p>By reading through the <a href="https://graphql.org/learn/">official documentation</a>, you should be able to know about GraphQL. </p>
<h2 id="How-to-query-a-GraphQL-server"><a href="#How-to-query-a-GraphQL-server" class="headerlink" title="How to query a GraphQL server"></a>How to query a GraphQL server</h2><p>When querying, GraphQL asks for specific fields on objects. We can also pass arguments to fields to get more specific field results. In GraphQL, every field and nested object can get its own set of arguments, making GraphQL a complete replacement for making multiple API fetches.</p>
<p>Since the result object fields may not include the arguments we pass, you can’t directly query for the same field with different arguments. So it lets you rename the result (aliase). </p>
<p>If we requires a fileds multiple times, we can use GraphQL’s reusable units called fragments. (construct sets of fields and we can include them in queries wherever we want)</p>
<p>GraphQL queries always end at scalar values.</p>
<p>Each field on each type is backed by a function called the resolver which is provided by the GraphQL server developer. </p>
<p>A resolver function receives four arguments:</p>
<ol>
<li><strong>obj</strong>: The previous object, which for a field on the root Query type is often not used.</li>
<li><strong>args</strong>: The arguments provided to the field in the GraphQL query.</li>
<li><strong>context</strong>: A value which is provided to every resolver and holds important contextual information like the currently logged in user, or access to a database.</li>
<li><strong>info</strong>: A value which holds field-specific information relevant to the current query as well as the schema details, also refer to type GraphQLResolveInfo for more details</li>
</ol>
<p>Resolve function can be asynchronous and needs to be aware of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>. </p>
<p>Different fields can be resolved concurrently.</p>
<h2 id="How-to-mutate-server-side-data"><a href="#How-to-mutate-server-side-data" class="headerlink" title="How to mutate server-side data"></a>How to mutate server-side data</h2><p>By convention, any operation involving writes should be sent via mutation. </p>
<p>While query fields are executed in parallel, mutation fields run in series, one after the other.</p>
<p>GraphQL also supports interfaces. An Interface is an abstract type that includes a certain set of fields that a type must include to implement the interface.</p>
<h2 id="How-to-build-GraphQL-APIs-using-Django"><a href="#How-to-build-GraphQL-APIs-using-Django" class="headerlink" title="How to build GraphQL APIs using Django"></a>How to build GraphQL APIs using Django</h2><p>In Python, we use <code>Graphene</code> as the library to implement GraphQL APIs. But when I implemented my Django based GraphQL APIs, I choose the <code>Graphene-Django</code> library. It is built upon <code>Graphene</code> and has some Django related features. The goal of it is to connect models from Django ORM to graphene object types.</p>
<p>In order to have GraphQL APIs in Django, we have to:</p>
<h3 id="Put-following-in-project-settings"><a href="#Put-following-in-project-settings" class="headerlink" title="Put following in project settings:"></a>Put following in project settings:</h3><pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># This will also make the `graphql_schema` management command available</span></span><br><span class="line">    <span class="string">&#x27;graphene_django&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="Put-following-in-project-url"><a href="#Put-following-in-project-url" class="headerlink" title="Put following in project url:"></a>Put following in project url:</h3><pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    ...</span><br><span class="line">    url(<span class="string">r&#x27;^graphql$&#x27;</span>, GraphQLView.as_view(graphiql=<span class="literal">True</span>, schema=schema&#125;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="Define-a-global-schema-combining-all-apps-schema-in-project-schema-py"><a href="#Define-a-global-schema-combining-all-apps-schema-in-project-schema-py" class="headerlink" title="Define a global schema (combining all apps schema) in project.schema.py:"></a>Define a global schema (combining all apps schema) in <code>project.schema.py</code>:</h3><pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Query</span>(app1.schema.Query,</span><br><span class="line">            app2.schema.Query,</span><br><span class="line">            ...,</span><br><span class="line">            graphene.ObjectType):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mutation</span>(app1.schema.Mutation, </span><br><span class="line">               app2.schema.Mutation,</span><br><span class="line">               ...,</span><br><span class="line">               graphene.ObjectType):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">schema = graphene.Schema(query=Query, mutation=Mutation)</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="Define-each-Query-Mutation-in-each-relative-app"><a href="#Define-each-Query-Mutation-in-each-relative-app" class="headerlink" title="Define each Query/Mutation in each relative app."></a>Define each Query/Mutation in each relative app.</h3><p>This is for the modularization purpose</p>
<h2 id="GraphQL-good-and-bad"><a href="#GraphQL-good-and-bad" class="headerlink" title="GraphQL good and bad"></a>GraphQL good and bad</h2><p>Compared with REST, GraphQL does has a bunch of advantages. But it also has some short-comes.</p>
<h3 id="The-good"><a href="#The-good" class="headerlink" title="The good:"></a>The good:</h3><ul>
<li>Client can get exact what they need and receive data in expected formats. </li>
<li>Users can know what data is available since GraphQL service defines a set of types which completely describe the set of possible data you can query on that service</li>
<li>Can fetch all required data with one single request. </li>
<li>…</li>
</ul>
<h3 id="The-bad"><a href="#The-bad" class="headerlink" title="The bad:"></a>The bad:</h3><ul>
<li>Caching control. Caching is built into in the HTTP specification which RESTful APIs are able to leverage. But in GraphQL since there is only one endpoint, it’s complex to control caching. </li>
<li>Complex to do error handle since queries always return a HTTP status code of 200</li>
<li>More engineer work. Developers has to define a GraphQL schema</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Knowledge</category>
      </categories>
      <tags>
        <tag>GraphQL</tag>
        <tag>Django</tag>
        <tag>backend</tag>
      </tags>
  </entry>
  <entry>
    <title>写在重启blog前</title>
    <url>/2019/11/11/%E5%86%99%E5%9C%A8%E9%87%8D%E5%90%AFblog%E5%89%8D/</url>
    <content><![CDATA[<p>打开个人网站，发现自己有一年多没有碰过blog了，或许日常的工作生活已经耗尽了自己全部的气力，但细想下却并不尽然，只不过是许多宝贵的时间在无意义的视频和游戏中消逝罢了。漫无目的的生活的确很不可取，所以我想借最近较为空闲的时间以及放松的心情之际，重新开始写blog，希望在整理的同时也能对自己的技术有进一步的提升。</p>
<span id="more"></span>
<p>都说万事开头难，我觉得重启博客也是亦然。一年多的工作生活带给我很多的感触，有很多想写但又不知从何落笔，犹豫之际又虚度了不少韶光。</p>
<p>思来想去，不如就对自己一年多学到的新知识做个总结整理，同时也对在职跳槽给出一些自己切身的感受和意见，最后再为近期的自己制定一些计划吧。</p>
<p>Anyway，接下来我会写几篇blog，详细介绍一下以下这些这一年新学的知识：</p>
<ol>
<li>process real-time streaming data 在工业界的应用 （Kafka，Pulsar 以及两者的比较）</li>
<li>Containerize 的应用 （docker，K8s）</li>
<li><a href="https://tianyuh.com/2019/11/12/GraphQL%E7%AE%80%E4%BB%8B/">GraphQL 的使用以及如何基于Django部署</a></li>
<li>Database的选择、优化及使用 （Postgres，SQLAlchemy）</li>
<li>Production 环境下的一些注意事项</li>
<li>Python 的一些总结整理</li>
</ol>
<p>一些关于工作生活的blog：</p>
<ol>
<li>介绍美国的职场生活</li>
<li>如何准备在职跳槽</li>
<li>对行业前景的一些浅见</li>
<li>美国生活的一些感悟</li>
<li>在美国做手术是怎样的体验</li>
<li>RED DEATH REDEMPTION 2 游戏体验及感悟</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>在Windows平台下编译并运行TensorFlow C++项目（支持GPU）</title>
    <url>/2018/09/11/Build-Run-Tensorflow-C-program-on-Windows/</url>
    <content><![CDATA[<p>由于工作需要，最近我尝试了在Windows平台上编译并运行TensorFlow的C++项目。整个过程非常痛苦，因为网上相关的信息实在是少之又少，几乎所有关于C++的编译都是在Linux平台下通过baze实现的。非常感谢这篇<a href="https://joe-antognini.github.io/machine-learning/build-windows-tf">tutorial</a> 以及 这篇 <a href="https://joe-antognini.github.io/machine-learning/windows-tf-project">tutorial</a>。通过结合上面两篇博文以及TF的官方<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/cmake/README.md">CMake介绍</a>，我终于成功实现了在Windows平台下对TensorFlow项目的编译和运行。(趁热赶紧回馈社会…</p>
<span id="more"></span>
<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>应client的要求，我们需要在Windows 7 pro的环境下提供一个基于 TensorFlow 做 Inference 的 DLL，以供他们在VS2015中调用。</p>
<p>所以，本文介绍的编译及运行的方法仅保证在以下环境下能够成功：</p>
<ul>
<li>OS Platform: Windows 7 Pro</li>
<li>Tensorflow 1.5</li>
<li>Visual Studio 2015</li>
</ul>
<h2 id="Build-TensorFlow"><a href="#Build-TensorFlow" class="headerlink" title="Build TensorFlow"></a>Build TensorFlow</h2><p>如果你有过bazel build的经验，你应该知道：要想构建C++项目，首先需要build TensorFlow。这里我们将用 vs-2015 来完成编译。</p>
<h3 id="Pre-requirement"><a href="#Pre-requirement" class="headerlink" title="Pre-requirement"></a>Pre-requirement</h3><p>首先，我们需要完成一些先期工作，确保以下已存在于Windows中：</p>
<ul>
<li>tensorflow 1.5. <ul>
<li>git clone <a href="https://github.com/tensorflow/tensorflow.git">https://github.com/tensorflow/tensorflow.git</a> v1.5.0</li>
<li>cd v1.5.0</li>
<li>git checkout tags/v1.5.0</li>
</ul>
</li>
<li>CMake</li>
<li>SWIG (3.0.12)</li>
<li>python3.5</li>
<li>Visual Studio 2015</li>
</ul>
<p>为了方便，在具体操作过程中，我将TensorFlow和swig放入了<code>c:\%USERNAME%\bin\</code>文件夹下，以下都将使用该路径</p>
<h3 id="CMake-生成-Visual-Studio-project-files"><a href="#CMake-生成-Visual-Studio-project-files" class="headerlink" title="CMake 生成 Visual Studio project files"></a>CMake 生成 Visual Studio project files</h3><p>所有即将编译的TensorFlow library都在TensorFlow repository下的<code>cmake</code>目录下。首先我们要在<code>cmake</code>文件夹下创建一个separate的<code>build</code>文件夹。(以下所有命令行操作都是在Command Prompt下进行的)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\...&gt; cd tensorflow\tensorflow\contrib\cmake</span><br><span class="line">C:\...&gt; mkdir build</span><br><span class="line">C:\...&gt; cd build</span><br></pre></td></tr></table></figure>
<p>然后我们使用Command Prompt来运行CMake：（路径根据实际情况可能需要修改）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake .. -A x64 -DCMAKE_BUILD_TYPE=Release ^</span><br><span class="line">-DSWIG_EXECUTABLE=C:\Users\%USERNAME%\bin\swig\swigwin-3.0.12\swig.exe ^</span><br><span class="line">-DPYTHON_EXECUTABLE=C:\Users\%USERNAME%\Anaconda3\python.exe ^</span><br><span class="line">-DPYTHON_LIBRARIES=C:\Users\%USERNAME%\Anaconda3\libs\python35.lib</span><br></pre></td></tr></table></figure>
<p>如果你和我一样也是需要一个GPU support的program，需要在加上：（别忘记在前面的命令行后面加上<code>^</code>，cudnn路径根据实际情况调整）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dtensorflow_ENABLE_GPU=ON ^</span><br><span class="line">-DCUDNN_HOME=&quot;C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0&quot;</span><br></pre></td></tr></table></figure>
<p>为了节省时间，我们最后避免一些不必要的文件的生成，加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dtensorflow_BUILD_PYTHON_BINDINGS=OFF ^</span><br><span class="line">-Dtensorflow_ENABLE_GRPC_SUPPORT=OFF</span><br></pre></td></tr></table></figure>
<p>最重要的是，如果我们想得到shared library，<strong>一定要加</strong>:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dtensorflow_BUILD_SHARED_LIB=ON ^</span><br><span class="line">-DCUDA_HOST_COMPILER=&quot;C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\amd64\cl.exe&quot;</span><br></pre></td></tr></table></figure></p>
<p>这样在CMake成功之后，会生成很多Visual Studio project file</p>
<h3 id="Build-TensorFlow-in-VIsual-Studio"><a href="#Build-TensorFlow-in-VIsual-Studio" class="headerlink" title="Build TensorFlow in VIsual Studio"></a>Build TensorFlow in VIsual Studio</h3><p>点击<code>tensorflow.sln</code>文件，会打开vs工程。很重要的是：一定要在Configuration Manager中（或者在上边栏）选择<strong>64-bit build</strong>以及<strong>Release</strong>。</p>
<p>然后在 solution 中选择<code>ALL_BUILD</code>进行build，（接下来能做的就只能双手合十祈祷不报错了</p>
<p>这一步一般要花费2-3小时左右（视机器而定），一定要保证有至少12GB的内存，不然会在编译一小时左右报一个 <code>out of space</code> 的 error</p>
<p>如果一切顺利，那么在编译成功后我们得到一系列的library，其中最重要的是在路径 <code>tensorflow\contrib\cmake\build\Release</code> 下的 <code>tensorflow.dll</code> 和 <code>tensorflow.lib</code></p>
<h2 id="Build-Projects-Depending-on-TensorFlow"><a href="#Build-Projects-Depending-on-TensorFlow" class="headerlink" title="Build Projects Depending on TensorFlow"></a>Build Projects Depending on TensorFlow</h2><p>在成功编译得到 <code>tensorflow.dll</code> 和 <code>tensorflow.lib</code> 后，我们就可以构建基于TensorFlow的程序了！</p>
<p>首先要注意的我们的程序一定要是<strong>x64</strong>下的<strong>Release</strong>！（和编译TensorFlow时对应）</p>
<p>在构建程序的时候，有一点一定要记住，一定要将下列code写入你的头文件中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMPILER_MSVC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOMINMAX</span></span><br></pre></td></tr></table></figure>
<p>否则会报一个 <code>&quot;You must define TF_LIB_GTL_ALIGNED_CHAR_ARRAY for your compiler.&quot;</code>的error</p>
<p>接来下需要修改下列设置:</p>
<h3 id="Additional-Include-Directories"><a href="#Additional-Include-Directories" class="headerlink" title="Additional Include Directories"></a>Additional Include Directories</h3><p>在c++程序中，compiler需要所有必要的header files，所以在我们这个基于TensorFlow的程序中，需要额外引入directories以避免compile error：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\%USERNAME%\bin\v1.5.0</span><br><span class="line">C:\Users\%USERNAME%\bin\v1.5.0\tensorflow\contrib\cmake\build</span><br><span class="line">C:\Users\%USERNAME%\bin\v1.5.0\tensorflow\contrib\cmake\build\external\eigen_archive</span><br><span class="line">C:\Users\%USERNAME%\bin\v1.5.0\third_party\eigen3</span><br><span class="line">C:\Users\%USERNAME%\bin\v1.5.0\tensorflow\contrib\cmake\build\protobuf\src\protobuf\src</span><br><span class="line">C:\Users\%USERNAME%\bin\v1.5.0\tensorflow\contrib\cmake\build\nsync\src\nsync\public</span><br></pre></td></tr></table></figure></p>
<h3 id="ADD-tensorflow-lib"><a href="#ADD-tensorflow-lib" class="headerlink" title="ADD tensorflow.lib"></a>ADD tensorflow.lib</h3><p>将路径在<code>tensorflow\contrib\cmake\build\Release</code> 下的 <code>tensorflow.lib</code> 添加到当前项目下，确保不会有compile的linking error。</p>
<p>根据不同项目，这里可能需要额外的lib文件：我就添加了如下两个static library：</p>
<ul>
<li><code>tf_protos_cc.lib</code> in <code>tensorflow\contrib\cmake\build\Release</code> </li>
<li><code>libprotobuf.lib</code> in <code>tensorflow\contrib\cmake\build\protobuf\src\protobuf\Release</code></li>
</ul>
<h3 id="ADD-tensorflow-dll"><a href="#ADD-tensorflow-dll" class="headerlink" title="ADD tensorflow.dll"></a>ADD tensorflow.dll</h3><p>follow 上述步骤后，我们就可以成功编译项目了。但是先别高兴太早，好没结束呢，现在run生成的exe文件会直接报错显示缺失<code>tensorflow.dll</code>文件，这时就需要我们将路径在<code>tensorflow\contrib\cmake\build\Release</code> 的<code>tensorflow.dll</code>文件复制到和exe文件所在的文件夹中，即可成功运行</p>
<p>(可以用这篇 <a href="https://joe-antognini.github.io/machine-learning/windows-tf-project">tutorial</a>中的示例代码进行验证)</p>
<p>Happy Coding!</p>
<p>（完）</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>工欲善其事</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>Windows</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集算法简介</title>
    <url>/2018/09/09/Union-Find/</url>
    <content><![CDATA[<p>本文将简要介绍并查集算法。</p>
<span id="more"></span>
<h2 id="并查集算法"><a href="#并查集算法" class="headerlink" title="并查集算法"></a>并查集算法</h2><p>对于动态连通性的问题，一般都可以用并查集算法解决。</p>
<p>假设给定一个有<code>n</code>个节点的<code>graph</code>，我们首先要构建两个大小为<code>n</code>的orders和rank的list。其中：orders表示的是与该节点联通的父节点（未联通时为-1），rank表示的是联通时的等级，每次联通时都并入等级高的part（如果等级相同时随机并入并更新并入后的节点的rank）。</p>
<p>算法步骤如下：</p>
<ul>
<li>构建rank和orders两个list，rank初始都为0，orders初始都为-1.</li>
<li>构建find方法，用递归的方法更新每个节点的父节点</li>
<li>构建union方法，找出两个节点对应的父节点，比较父节点的rank，并入等级高的父节点。若两个父节点的rank相等，则并入第一个父节点并对第一个父节点的rank+1</li>
</ul>
<p>以下为python代码部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.orders = [-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        self.rank = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># count stands for number of connected part</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setOrders</span>(<span class="params">self, i</span>):</span><br><span class="line">        self.orders[i] = i</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="keyword">return</span> self.orders[i] &gt;= <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="comment"># here use recursive way to update the orders.</span></span><br><span class="line">        <span class="keyword">if</span> self.orders[i] != i:</span><br><span class="line">            self.orders[i] = self.find(self.orders[i])</span><br><span class="line">        <span class="keyword">return</span> self.orders[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, i, j</span>):</span><br><span class="line">        x = self.find(i)</span><br><span class="line">        y = self.find(j)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> x != y:</span><br><span class="line">            <span class="keyword">if</span> self.rank[x] &gt; self.rank[y]:</span><br><span class="line">                self.orders[y] = self.orders[x]</span><br><span class="line">            <span class="keyword">elif</span> self.rank[x] &lt; self.rank[y]:</span><br><span class="line">                self.orders[x] = self.orders[y]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.orders[y] = self.orders[x]</span><br><span class="line">                self.rank[x] += <span class="number">1</span></span><br><span class="line">            self.count -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="Minimum-Spanning-Tree-最小生成树"><a href="#Minimum-Spanning-Tree-最小生成树" class="headerlink" title="Minimum Spanning Tree 最小生成树"></a>Minimum Spanning Tree 最小生成树</h3><p>最小生成树的定义： </p>
<ol>
<li>首先要有一个带权重值的无向图，也就是Edge不再仅仅是连接两个vertex，还具有一个权重值weight </li>
<li>最小生成树就是这个Graph的一棵子树，包含了Graph中的所有节点，并且没有任何的循环和周期 </li>
<li>最小生成树中的所有连接线的权重加起来为最小 </li>
</ol>
<p>最小生成树的解法是基于贪心法的kruskal算法，用union-find来判断图是否会构成一个环</p>
<p>具体算法步骤如下所示:</p>
<ol>
<li>对edge基于weight进行sort</li>
<li>选取weight最小的edge，判断是否和已生成的树构成环，若无则选取该edge，反之则放弃该edge</li>
<li>重复步骤2知道最小生成树中包含了v-1个edge</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Knowledge</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>用github搭建hexo静态博客</title>
    <url>/2018/09/06/Build-Hexo-Environment/</url>
    <content><![CDATA[<p>本文将简单介绍下如何用github搭建hexo静态博客。</p>
<span id="more"></span>
<p>挖坟抢救下我的blog。。。不知不觉已经有一年多没有更新过了，简直是懒癌的最高境界啊。</p>
<p>为了唤醒下我的记忆，本篇先从基本的配置hexo环境并利用github搭建一个属于自己的静态博客开始介绍吧。和其他教程不同的是，本篇教程介绍的是一种可以对hexo source files（而非发布files）进行版本控制，从而使得能在多台pc上进行博客修改的方法。</p>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>根据<a href="https://hexo.io/docs/">官网的教程</a>中的安装走一遍就行啦。</p>
<ul>
<li>安装 git</li>
<li>安装 Node.js</li>
<li>安装 Hexo</li>
</ul>
<p>这里不做赘述</p>
<h2 id="Start-Hexo"><a href="#Start-Hexo" class="headerlink" title="Start Hexo"></a>Start Hexo</h2><p>安装完成后，我们就可以着手开始hexo的设置了。</p>
<p>首先过一遍官方<a href="https://hexo.io/docs/setup">设置教程</a>，记在心里就可以了，接下来首先需要设置github从而使得能够对Hexo的source进行版本控制。</p>
<h3 id="Github设置"><a href="#Github设置" class="headerlink" title="Github设置"></a>Github设置</h3><p>在介绍如何设置Hexo之前，首先需要了解下我们deploy的环境——github。</p>
<p>每个用户，都可以在github上搭建属于自己的site，详见<a href="https://github.io/">Github.io</a>。我们只需创建一个以 <em>username.github.io</em> 结尾的repository，即可搭建属于自己的静态网页。</p>
<p>而对于hexo而言，通过设置blog文件夹下的<code>_config.yml</code>文件，我们可以将hexo生成的结果deploy到任一一个remote repository上。但是这样的话，一旦你想要用别的电脑修改并发布blog，就必须复制原有的文件，并且非常不利于版本控制。所以我的想法是利用这个<em>username.github.io</em>  repository，即实现对hexo source 的版本控制，又能够构建一个属于自己的网站。</p>
<p>如何实现呢？利用branch！</p>
<p>在<em>username.github.io</em>下新建一个branch（姑且叫<code>hexo</code>），<code>master</code> 用于hexo的deploy，<code>hexo</code>用于实现source文件的版本控制。</p>
<p>首先在github上创建一个<em>username.github.io</em> 的仓库</p>
<p>cd到在你想要创建博客的文件夹下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/[username]/username.github.io.git</span><br><span class="line"><span class="built_in">mv</span> username.github.io.git &lt;blog-folder-name&gt;  <span class="comment">#如果不嫌文件名难看的话，就不用这条指令改名字了</span></span><br><span class="line"><span class="built_in">cd</span> &lt;blog-folder-name&gt;</span><br><span class="line">git branch hexo     <span class="comment"># 新建branch</span></span><br><span class="line">git checkout hexo   <span class="comment"># checkout new branch</span></span><br></pre></td></tr></table></figure>
<p>接下来我们就可以在hexo branch下进行操作了</p>
<h2 id="Hexo-setup"><a href="#Hexo-setup" class="headerlink" title="Hexo setup"></a>Hexo setup</h2><p>现在，可以走一遍<a href="https://hexo.io/docs/setup">设置教程</a>了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">hexo init &lt;blog-folder-name&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;blog-folder-name&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>初始化结束！</p>
<p>站点的设置信息都在<code>_config.yml</code>中，通过设置实现deploy到github上</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">git@github.com:username/username</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world!"></a>Hello world!</h2><p>好啦，接下来就可以写文章发布blog了。(第一篇当然是hello world?</p>
<p>cd到<code>blog</code>文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;hello-world&quot;</span><br></pre></td></tr></table></figure>
<p>此时<code>./source/_posts</code>下就会出现一个<code>hello-world.md</code>的文件，用markdown编辑好 (hello world)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate       <span class="comment"># generate static pages</span></span><br><span class="line">hexo deploy         <span class="comment"># deploy (to github)</span></span><br></pre></td></tr></table></figure>
<p>如此，你的第一篇<code>hello world</code>就诞生了</p>
<h2 id="Hexo-进阶"><a href="#Hexo-进阶" class="headerlink" title="Hexo 进阶"></a>Hexo 进阶</h2><p>如果你想更进一步的话，我想以下的这些链接或许会对你有用：</p>
<ul>
<li><a href="http://gonghonglou.com/2016/02/03/firstblog/">绑定个人域名</a></li>
<li><a href="http://theme-next.iissnan.com/">next 主题</a>: 个人非常喜欢这种简洁风</li>
<li><a href="http://blog.junyu.io/posts/0010-hexo-learn-from-Never-yu.html">next 主题配置进阶</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next/issues/1282">更多示例</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>工欲善其事</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>再见多说，你好Disqus</title>
    <url>/2017/05/29/%E5%86%8D%E8%A7%81%E5%A4%9A%E8%AF%B4%EF%BC%8C%E4%BD%A0%E5%A5%BDDisqus/</url>
    <content><![CDATA[<p>早在三个月前就知晓了多说将在6月1日后关闭的噩耗，然而懒癌晚期患者不到最后一刻是不会做出行动的。花了半小时的时间完成了Disqus的搭建，相信这款墙外产品一定会有着比多说更好的体验（前提是梯子要稳。。。）</p>
<span id="more"></span>
<p>由于我的hexo选用的主题的next，内置config就支持Disqus的使用，所以我们只需要在Disqus上注册生成一个site(通过首页上点击get started进入)，然后将shortname输入config文件中即可，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disqus:</span><br><span class="line">  enable: true</span><br><span class="line">  shortname: your-shortname</span><br><span class="line">  count: true</span><br></pre></td></tr></table></figure>
<p>Disqus的相关注册问题可以参考<a href="http://www.jianshu.com/p/c4f65ebe23ad">这篇文章</a></p>
<p>配置完成后，只要更新hexo即可启用Disqus评论，enjoy it！</p>
<p>（至于如何将原有的评论从多说导出到Disqus，<a href="https://github.com/JamesPan/duoshuo-migrator">github上的这篇文章</a>已经说的很详细，按步骤做就行，很方便的）。</p>
<p>最后再说一遍，国内用梯子一定要稳，一定要稳！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>工欲善其事</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>comment</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven的配置(Mac)</title>
    <url>/2017/05/28/%E9%85%8D%E7%BD%AEMaven/</url>
    <content><![CDATA[<p>最近在公司负责一款避孕智能咨询的聊天机器人，是嵌入手淘中的。上周刚刚基于Lucene为机器人添加了搜索引擎，在项目进行的过程中深深领略到了maven的过人之处。<br><span id="more"></span></p>
<p>maven作为一款Java项目的管理工具，在项目依赖管理上的优点简直完美！只需在pom中添加一小段描述以及配置信息，就可以在项目里调用外包中的函数，岂不美哉，下面简要介绍下Maven的配置和使用。</p>
<p>首先从官网下载最新的maven的binary并进行解压。然后我们需要确定在Mac上已经设置了JAVA_HOME并指向了你的jdk安装位置，没有的话在Terminal中进行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vi ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_8_HOME=your_java8_home</span><br><span class="line">export JAVA_7_HOME=your_java7_home</span><br><span class="line">export JAVA_HOME=$JAVA_8_HOME</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure>
<p>此时我们已经添加了JAVA_HOME，现在需要安装maven，同样也是在该文件下进行添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export MAVEN_HOME=your_maven_download_dir</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/bin</span><br></pre></td></tr></table></figure>
<p>退出后更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>这时输入mvn -v应该可以看到Maven的相关信息</p>
<p>安装完成！</p>
<p>至于maven的使用，墙裂推荐使用JetBrains系列下的IDEA，反正对教育邮箱都是免费的，很赞。我接下来会通过一个简单的项目介绍Lucene，届时也会进一步深入maven的使用。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>工欲善其事</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>maven</tag>
        <tag>Java</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>香港游记（一）—— 暴走HK</title>
    <url>/2017/04/11/%E9%A6%99%E6%B8%AF%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>游历了不少祖国的大川大山，走过了许多塞外的草原沙丘，我一直想体验一番现代都市的独特魅力。趁着入职前的空档，我和室友抽空去香港转了一番。此行若不以游记的形式展现出来，那就实在是太虚度光阴了，我将分成三篇随笔，简要介绍下此次的香港之行。<br><span id="more"></span></p>
<h2 id="匆忙的起始"><a href="#匆忙的起始" class="headerlink" title="匆忙的起始"></a>匆忙的起始</h2><p>此行的香港之行可以说是一趟说走就走的旅程。之前一直嘴上喊着拿到实习offer就立马开赴香港，然而当offer真正到来的时候我也是着实犹豫了很久才最终下定了赴港的决心。多亏了璠哥一个月前的经验，我几乎没用花太多的时间准备行程，比较轻松地就定下了四天后前往香港的旅程。</p>
<p>虽是定的周日启程，但是上午还得参加组会。尽管我早就和导师言及了去实习的事，但是内心还是非常挣扎的想要站好最后一班岗，周日的组会时间总是这么的尴尬，这次也不例外，启程前的组会变得如此的漫长。</p>
<p>熬到了组会结束，我立马飞奔回寝室整好行李后直接开赴广州东站，坐上了开往hk的绿皮列车广九线。不得不说广九线入港比从深圳入关方便许多，既不用排很长的队伍，又可以直接在闹市区下站，节省了大把的时间。</p>
<p>红磡下车，绕着车站没边际地走了一圈，才在百度地图的指引和对面红砖砌成的港理工的参照下找回了方位感。为了更好地体验香港，我们决定开着11路直奔维港的天星小轮码头，在沿途我还特意找了执念许久的第三代肥仔小食店，品尝了大生肠、火鸡肾和大墨鱼，简直美味！独特的口味深受喜欢猎奇的我的喜爱。而这种酒香巷深的既视感也充满了独特的市井气息。</p>
<p><img src="/images/old-resources/IMG_1567 2.jpg?imageMogr2/rotate/90" alt="IMG_1567 2"></p>
<p><img src="/images/old-resources/IMG_1598 2.jpg?imageMogr2/rotate/90" alt="IMG_1598 2"></p>
<p>然后又左拐右拐穿过一个又一个小巷，去了池记吃到了美味的蟹黄粥，赶在日落前走到维港坐上了天星小轮，横渡到了中环。然后又以惊人的体力开着11路走了2公里多抵达酒店。这还不算完，放下行李稍作歇息，我和室友又马不停蹄从港大后门绕道上了太平山。</p>
<p><img src="/images/old-resources/IMG_1569.jpg?imageMogr2/rotate/90" alt="IMG_1569"></p>
<p><img src="/images/old-resources/IMG_1578.jpg" alt="IMG_1578"></p>
<h2 id="夜上太平山"><a href="#夜上太平山" class="headerlink" title="夜上太平山"></a>夜上太平山</h2><p>夜晚的太平山上山小道格外静谧，几乎看不到一个人影，只有不时乱做的风吹打着道路两边的灌木，与昏暗的灯光一起构成了诡异的氛围。想必是之前听到些太平山的奇闻怪事吧，此时此刻我竟有些慌乱，额头有些渗出冷汗。是夜的太平山云雾缭绕，行及山腰就一片朦胧，水气弥漫了。据说站在太平山顶眺望香港城，可以切身感受到什么叫做繁华都市，什么叫做摩登时代。做攻略时我也对不少星光熠熠的美景图垂涎三尺。可惜这一切都随着雾气的弥漫消失殆尽，虽然山顶的大风源源不断地将雾气推向一座座摩天大楼，但是身后的浓雾马上又马不停蹄地接了上来，只有短短的几瞬才能让我拍出几张朦胧之美的夜香港。无奈的我只能和室友调侃到看来是要用去雾算法处理图像了哈哈。或许人生就应该是这样带有遗憾的吧，挺好，给我下次来香港增添一些憧憬吧。</p>
<p><img src="/images/old-resources/IMG_1626.jpg" alt="IMG_1626"></p>
<p>不同于印象中的游记写的那样人流众多，此时的山顶不过寥寥几人，或许是10点多的关系，又或许是这不识时务的云雾所致吧。下山的缆车竟然出人意料地不用排队，我们顺顺当当的坐上了下山缆车，又开启了11路走到了兰桂坊，打算替璠哥完成未能逛夜店的遗憾。还未走近我们就听到了阵阵嘈杂的喧哗声，一群群拿着酒杯的外国人堆叠在一个个酒吧的门口，有又唱又跳的，有左拥右抱的，还有激情谈论的，我们深感与此处的格格不入，又实在不忍心就这样弃夜香港于不顾，只好在周招找了一个相对安静点的正放着球赛的酒吧，点了几杯啤酒边看球赛边评头论足。</p>
<p><img src="/images/old-resources/IMG_1641.jpg?imageMogr2/rotate/90" alt="IMG_1641"></p>
<p>或许这种热闹的氛围会传染吧，一对对身着奇装异服的外国人在店门口驻足停留，我忍不住走上前去要求合影，于是就有了这样的囧样</p>
<p><img src="/images/old-resources/IMG_1642.jpg?imageMogr2/rotate/90" alt="IMG_1642"></p>
<p>清吧的酒或许终究没有劲吧来的好喝吧，手中的啤酒越喝越苦，人也越来越困，忙不迭的干完剩余的酒踏上了回宾馆的路。</p>
<p>如果是这就是我们香港之旅的第一天的话，那可真的是够疯狂的。可是疯狂的事情还没结束呢，才刚刚走出兰桂坊，我就瞅见了翠华那大大的招牌，心想那敢情好啊，送上门的美食哪能不吃？可是嘴上却说太晚了不吃了要忍住。要是我真的是能忍住的动物就好了，走了两三步毅然回头冲入酒店开吃，一碗虾子云吞面一份猪扒包甚慰我心我胃。</p>
<p><img src="/images/old-resources/IMG_1649.jpg?imageMogr2/rotate/90" alt="IMG_1649"><br><img src="/images/old-resources/IMG_1647.jpg?imageMogr2/rotate/90" alt="IMG_1647"></p>
<p>酒足饭饱早已离地铁关门时间过去了一个小时，心想反正也不差这点步数了，就又开了好久的11路才回到宾馆，此时早已过了凌晨两点好久了，身心俱疲，不过内心那种见证过夜香港的自豪根本压抑不住。what a day！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>香港</tag>
      </tags>
  </entry>
  <entry>
    <title>语音识别简介（一）——特征提取</title>
    <url>/2017/04/03/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E7%AE%80%E4%BB%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>上学期，我们学习了 “Design and Implementation of Speech Recognition System” 这门课 （CMU 18799）。通过这门课的学习，我们了解语音识别的基础知识并最终实现了连续语音的识别（采用HMM-GMM模型）。本文主要介绍下进行语音识别前的一些预处理工作，即是如何提取出特征的。<br><span id="more"></span></p>
<p>就提取特征的预处理而言，具体可以分为这几个步骤：采样、分帧加窗、endpointing、MFCC、DCT到一个确定的维度。</p>
<p><img src="/images/old-resources/14912265291837.jpg" alt=""></p>
<p><img src="/images/old-resources/14912269630817.jpg" alt=""></p>
<h2 id="Sampling-采样（录制）"><a href="#Sampling-采样（录制）" class="headerlink" title="Sampling 采样（录制）"></a>Sampling 采样（录制）</h2><p>现实中的声音属于一种模拟信号，要想让计算机能够对声音进行处理，我们首先要做的就是将模拟信号转换为数字信号。那么我们又该如何用计算机实现这个采样的过程呢？在具体操作的过程中，我们使用的是 PortAudio 开源库来录制声音。</p>
<p>我当时是在Mac OS系统下用Xcode配置了PortAudio，具体的配置过程可以参见<a href="http://blog.csdn.net/u013080641/article/details/44205049">这篇博文</a>，在此不作赘述。</p>
<p>于是通过PortAudio这个库我们可以实现语音的录制，即采样。得到的文件中的数值参见具体的文件后缀格式而定。接下来我们需要对语音进行分帧处理</p>
<h2 id="分帧加窗"><a href="#分帧加窗" class="headerlink" title="分帧加窗"></a>分帧加窗</h2><p>为了更好地去除噪声的影响，我们需要加一个preemphasize 的过程：即 $s[n] = s[n] - \alpha * s[n - 1]，\alpha$一般接近1.</p>
<p>在Mac OS系统下，一般采用的采样频率是44100hz，每个点代表的时间约为0.02ms，对于声音信号而言，这个范围太小了，既没有区间差异性又会导致计算量的增多，所以我们这里将20ms这一时间段视为一个特征点，这就需要我们进行分帧处理，一般采用移动窗函数来实现，帧与帧之间有overlap，这里我们将overlap定为10ms，之所以要有overlap是为了更好地描述上一帧中被忽略的部分，防止信息的丢失。</p>
<p><img src="/images/old-resources/14912238254847.jpg" alt=""></p>
<p>由于有了overlap，所以如果用rectangular 窗函数进行分帧的话会导致不平滑的现象，在这里我们采用hanning窗函数进行分帧，可以得到平滑的帧。同时加窗函数的意义还在于可以比截断部分刚好地体现出原始信号的频率信息：</p>
<p><img src="/images/old-resources/14912244314593.jpg" alt=""></p>
<p>最终得到的是就是一帧帧的信号（可以理解为一个二维数组）。</p>
<h2 id="Endpointing"><a href="#Endpointing" class="headerlink" title="Endpointing"></a>Endpointing</h2><p>对于一串语音而言，其中有很大的一部分是没有声音的，尤其是以开头和结尾处为主。较多的non-speech部分不仅会导致不必要的计算负担，同时还可能会将non-speech的部分错误地识别成一些词。</p>
<p>为了防止出现这种现象，我们首先要找出speech region，即做一个endpointing：</p>
<p><img src="/images/old-resources/14912215577966.jpg" alt=""></p>
<p>如何endpointing呢？我们基于的原理就是speech region较之non-speech region有着较高的能量。一种最简单的方法就是直接对信号施加一个阈值，当能量超过阈值的时候，其对应的就很有可能是speech region。当然这种方法忽略了背景噪音等一些因素，因此往往不能准确对speech region进行划分。下面介绍两种更加准确的endpointing的方法：</p>
<p>第一种也叫做 Adaptive Endpointing Algorithm，其核心思想就是用一个smoothed signal level 和一个fast-varying estimation of background进行比较，之所以被称为adaptive就是指adapt background level。 伪代码见下图：</p>
<p><img src="/images/old-resources/14912221962848.jpg" alt=""></p>
<p>另一种更复杂一点的方法就是对speech部分的开始和结尾分别处理：开始部分会有一个很明显的能力增加的过程，即便是在高噪声的环境中仍然如此；而结束的部分由于延长音等一些因素，使得能量的降低不是那么明显，尤其是在高噪声的环境中更是如此，所以我们采用两个阈值分别处理语音的开始部分和结尾部分。伪代码见下：</p>
<p><img src="/images/old-resources/14912230370183.jpg" alt=""></p>
<h2 id="MFCC"><a href="#MFCC" class="headerlink" title="MFCC"></a>MFCC</h2><p>经过上述处理后，我们得到了一个包含着较少non-speech region的一帧帧信息，然而这里的信息都只是在时域上的，不能反映出什么，我们需要对其进行傅里叶变换，将其转为频域上的信息。</p>
<p>这里为了方便进行fft快速傅里叶变换，我们需要先进行zero padding的过程，关于zero-padding可以参见我之前的一篇<a href="http://tianyuh.com/2017/02/21/Zero-padding/">博文</a></p>
<p>将其转到频域之后，我们好像需要将频率匹配到是和人耳听觉的区域（即mel域）</p>
<p>mel域可以认为是对频域做一个warp的过程，每处的warp不同。这主要是由于人耳对低频变化比较敏感而对高频的不敏感。频域到mel域的公式为：</p>
<script type="math/tex; mode=display">
z = 1125 \ln(1 + \frac{f}{700})</script><p>下图中横轴是原始频域，纵轴是mel域。</p>
<p><img src="/images/old-resources/14912266519571.jpg" alt=""></p>
<p>实际操作时我们一般用一定数量的filter bank得到对应数目的mel域的值（一般采用三角滤波）（one value per filter）</p>
<p><img src="/images/old-resources/14912270108453.jpg" alt=""></p>
<p>为了对数据进行更好地压缩，我们再对求得的mel spectrum做一个log变换（同时也是为了reduce imbalance）</p>
<h2 id="DCT变换"><a href="#DCT变换" class="headerlink" title="DCT变换"></a>DCT变换</h2><p>得到了log mel spectrum的值后，每一帧的维度可以认为是filter的数目，为了方便计算我们还需要对其进行降维处理，这里采用的是DCT变换将维度变为13维。在DCT中减去的维度在不同声音间有着较小的变化。</p>
<p>在得到13维的特征向量之后，我们还想进一步得到一些关于频率变化的信息，于是我们对13维的每一维分别求一阶导和二阶导（由于一帧的时间很短，可以认为是$\Delta t$）最终得到的特征向量有39维度</p>
<p>通过上述这些方法，我们就得到了进行语音识别的特征点。</p>
<p>在下一节中我将介绍如何用DTW to HMM的方法进行简单的语音识别。</p>
<h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><p>这一部分的相关代码可以详见我的github中的 <a href="https://github.com/Htiango/SpeechRecognition">SpeechRecognition</a>项目</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Speech Recognizition</category>
      </categories>
      <tags>
        <tag>speech recognition</tag>
        <tag>feature extraction</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈主题模型（五）—— Reference</title>
    <url>/2017/03/28/%E6%B5%85%E8%B0%88%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p>承接“浅谈主题模型（四）”中的项目模型的介绍，本文主要展示下项目相关代码以及Reference。<br><span id="more"></span></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>LDA模型作为我毕设和省创的一个base，花了我相当多的时间来学习和理解，期间也查阅了许多的文献和博文，最终的代码实现也是一个坑一个坑踩出来的。</p>
<p>所以我在此将有用的资料一一列举出来，同时也将自己所有的代码开源化，希望大家能少走些弯路。</p>
<p>项目的相关代码详见我Github中的<a href="https://github.com/Htiango/Advanced-LDA-Program">Advanced-LDA-Program</a> </p>
<p>LDA的相关代码详见我Github中的<a href="https://github.com/Htiango/Chinese-LDA-v1.0">Chinese-LDA-v1.0</a></p>
<p>如果想学习FudanNLP的中文分词的使用，可以参见我Github中的<a href="https://github.com/Htiango/FudanNLP-Example">FudanNLP-Example</a></p>
<ol>
<li>Hofmann T. Probabilistic latent semantic indexing[C]//Proceedings of the 22nd annual international ACM SIGIR conference on Research and development in information retrieval. ACM, 1999: 50-57.</li>
<li>Blei D M, Ng A Y, Jordan M I. Latent dirichlet allocation[J]. the Journal of machine Learning research, 2003, 3: 993-1022.</li>
<li>Zhang K, Wu W, Wu H, et al. Question retrieval with high quality answers in community question answering[C]//Proceedings of the 23rd ACM International Conference on Conference on Information and Knowledge Management. ACM, 2014: 371-380.</li>
<li>Yang L, Qiu M, Gottipati S, et al. Cqarank: jointly model topics and expertise in community question answering[C]//Proceedings of the 22nd ACM international conference on Conference on information &amp; knowledge management. ACM, 2013: 99-108.</li>
<li><a href="http://blog.csdn.net/yangliuy/article/details/8330640">概率语言模型及其变形系列</a></li>
<li><a href="http://www.52nlp.cn/lda-math-%E6%B1%87%E6%80%BB-lda%E6%95%B0%E5%AD%A6%E5%85%AB%E5%8D%A6">LDA数学八卦</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/40984699">从贝叶斯方法谈到贝叶斯网络</a></li>
<li><a href="http://www.jianshu.com/p/50295398d802">LDA话题模型与推荐系统</a></li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>NLP</category>
        <category>Topic Model</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>LDA</tag>
        <tag>主题模型</tag>
        <tag>贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈主题模型（四）—— 项目简介</title>
    <url>/2017/03/28/%E6%B5%85%E8%B0%88%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p>承接“浅谈主题模型（三）”中的LDA模型的介绍，本文主要介绍我基于LDA模型的毕设和省创项目——UQA模型。<br><span id="more"></span></p>
<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>在当今的互联网时代，医疗服务不再仅仅是停留在线下的医院诊所里，我们还可以通过互联网获取各式各样的医疗服务，而这其中以网络社区的问答系统最为流行。</p>
<p>为了充分发挥网络问答社区的优势，我本次毕设项目的研究目的就是实现网络问答社区的智能推荐。通过问答社区中的海量问答信息，利用主题模型进行分析处理，实现对新输入问题的最佳答案以及最佳专家的智能推荐。不仅仅保证了推荐专家和推荐答案的准确性，同时还保证用户能够在第一时间内获取答案，不必再耗费大量的时间等待专家来进行回答。</p>
<h2 id="UQA模型简介"><a href="#UQA模型简介" class="headerlink" title="UQA模型简介"></a>UQA模型简介</h2><p>在 LDA 模型中，我们将文档视为一系列主题的分布，通过文档-主题以及主题-词这两个多项式分布实现了对文档中潜在主题的挖掘与分析。然而，结合我们的实验数据 (用户提问)，我们得出结论:专家进行问题回答时是有一定的偏向性的，每位专家有着他们各自偏好的东西，不仅仅是他们擅长的话题领域，还可以包括用户的提问方式等等。因此，我们假定除了主题之外，文档 D 中还有着吸引着专家对用户提问进行回答的东西，在本文中我们将其称之为专家专长(expertise)。因此，我们将专家和专家专长这两个概念引入原有的 LDA 模型中，构建一个基于 LDA 模型的 UQA(USER- QUESTION-ANSWER)模型，利用这个模型，我们不仅仅可以实现对新问题的最佳答案智能推荐，同时还可以实现对新问题的最佳专家推荐。</p>
<p>如下图所示的 UQA 模型中，我们在 LDA 的基础上补充如下定义:</p>
<ol>
<li>专家集U是所有回答专家的集合，表示为$U = {u_1, u_2, … , u_n}$</li>
<li>x表示专家转成，专长数为E个</li>
</ol>
<p>UQA模型为语料库D中的每个文档 w 假定以下生成过程:</p>
<ol>
<li>$\alpha, \beta, \gamma$分布为Dirichlet分布的先验参数： $\theta \sim Dir(\alpha) , \phi \sim Dir(\beta) , \psi \sim Dir(\gamma)$</li>
<li>θ为文档-主题的多项式分布，ψ为文档-专长的多项式分布，φ为主题/专长-词的联合多项式分布。</li>
<li>对于某一文档 d 中的词 w，取主题 $z \sim Multi(θ<em>d) $，专长$ x \sim Multi(\psi_d)$ ，生成对应词 $w~Multi(\phi</em>{z,x})$ （联合分布）</li>
</ol>
<p><img src="/images/old-resources/model 2.png" alt="model 2"></p>
<p>UQA模型中的文档-主题的多项式分布θ，文档-专长的多项式分布ψ，主题/专长-词的联合多项式分布φ都是通过Gibbs Sampling的方法得到，推导过程在论文中有详述。在这里只给出伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// zero all count variable NWZX, NZM, NXU, NS</span><br><span class="line">// Initialize</span><br><span class="line">foreach document m ∈ [1,D] do</span><br><span class="line"> get the author u of the this document m;</span><br><span class="line"> foreach word n ∈ [1, Nm] in document m do</span><br><span class="line">  sample topic index zm,n ~ Mult(1/K) for word wm,n;</span><br><span class="line">  sample expertise index xu,e ~ Mult(1/X) for word wm,n; </span><br><span class="line">// Here m also refers to the author u</span><br><span class="line">increment doc-topic count: NZM[zm,n][m]++;</span><br><span class="line">increment user-expertise count: NXU[xu,e][u]++;</span><br><span class="line">increment [topic,expertise]-word count: NWZX[wm,n][zm,n][xu,e]++;</span><br><span class="line">increment [topic,expertise]-word sum: NS[zm,n][xu,e]++;</span><br><span class="line"> end</span><br><span class="line">end</span><br><span class="line">// Gibbs Sampling</span><br><span class="line">while not finished do</span><br><span class="line"> foreach document m ∈ [1,D] do</span><br><span class="line">  get the author u of the this document m;</span><br><span class="line">  foreach word n ∈ [1, Nm] in document m do</span><br><span class="line">   NZM[zm,n][m]--;</span><br><span class="line">   NXU[xu,e][u]--;</span><br><span class="line">   NWZX[wm,n][zm,n][xu,e]--;</span><br><span class="line">   NS[zm,n][xu,e]--;</span><br><span class="line">   Sample topic and expertise index [z’m,n][x’u,e] according to Equ.32</span><br><span class="line">   // Because we have minused 1, so in Euq.32 we don’t need to -1</span><br><span class="line">   NZM[z’m,n][m]++;</span><br><span class="line">   NXU[x’u,e][u]++;</span><br><span class="line">   NWZX[wm,n][z’m,n][x’u,e]++;</span><br><span class="line">   NS[z’m,n][x’u,e]++;</span><br><span class="line">  end</span><br><span class="line">        if converged and L sampling iterations since last read out then </span><br><span class="line">            read out parameter set Θ, Φ, Ψ according to Equ.33, 34 and 35 in 2.2.2.3;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>利用 UQA 模型，我们可以获得文档潜在主题的分布与潜在专家专长分布，并利用这些信息实现对新问题的最佳答案智能推荐以及最佳专家的推荐。</p>
<p>最终也是用朴素贝叶斯找到训练集中与新输入问题最匹配的问题，其对应的答案即是最佳推荐答案</p>
<script type="math/tex; mode=display">
\begin{eqnarray} \nonumber
P(d|d_{new}) \propto P(d) P(d_{new} | d) & = & P(d) \prod_{w \in d_{new}} P(w | d) \\ \nonumber
& = &  P(d) \prod_{w \in d_{new}} \sum_z \phi_{w|z} \theta_{z|d} \\ \nonumber
& = & P(d) \prod_{w \in d_{new}} \sum_z (\sum_x \phi_{w|z,x}) \theta_{z|d} \\ \nonumber
\end{eqnarray}</script><p>通过上述这两个公式，我们可以获得训练集中一条提问在新问题下的匹配概率，通过遍历获取最大匹配概率，可以从训练集中获取最相似的问题，该最相似问题的答案即推荐答案。</p>
<p>对于 UQA 模型，我们可以利用贝叶斯定理得到新输入文档$d<em>{new}$与训练集中的 某一位专家 u 的匹配概率$P(u|d</em>{new})$(即在新文档发生的情况下，训练集中专家 u 的可能性)，具体公式推导见下：</p>
<script type="math/tex; mode=display">
\begin{eqnarray} \nonumber
P(u|d_{new}) \propto P(u) P(d_{new} | u) & = & P(u) \prod_{w \in d_{new}} P(w | u) \\ \nonumber
& = &  P(u) \prod_{w \in d_{new}} \sum_x \phi_{w,z|x} \psi_{x|u} \\ \nonumber
& = & P(u) \prod_{w \in d_{new}} \sum_x (\sum_z \phi_{w|x,z})\psi_{x|u}  \\ \nonumber
\end{eqnarray}</script><p>通过这个公式，我们可以获得训练集中一位专家在该新问题下的匹配概率，通过遍历获取最大匹配概率，可以从训练集答案中获取最匹配的推荐专家。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>以下通过图表简要介绍下项目结果。</p>
<p>下图是不同词典、不同主题数下，LDA模型得到的推荐答案的正确率：</p>
<p><img src="/images/old-resources/14908813671256.jpg" alt=""></p>
<p>下图是不同词典、不同主题数、不同专家专长数下，UQA模型得到的推荐答案的正确率：<br><img src="/images/old-resources/14908813307811.jpg" alt=""></p>
<p>下图是不同词典、不同主题数、不同专家专长数下，UQA模型得到的推荐专家的正确率：<br><img src="/images/old-resources/14908814051430.jpg" alt=""></p>
<p>在下一节我会将项目的reference以及项目代码展示出来。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>NLP</category>
        <category>Topic Model</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>LDA</tag>
        <tag>主题模型</tag>
        <tag>贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈主题模型（三）—— LDA模型简介</title>
    <url>/2017/03/28/%E6%B5%85%E8%B0%88%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>承接“浅谈主题模型（二）”中的LDA的概率知识，本文着重介绍LDA模型。<br><span id="more"></span></p>
<h2 id="LDA-Model"><a href="#LDA-Model" class="headerlink" title="LDA Model"></a>LDA Model</h2><p>LDA模型的本质是一个unigram模型，模型中每个词的生成都与上下文无关。unigram模型中假设文本中的词服从multinomial分布，同时multinomial分布的先验分布为Dirichlet分布。</p>
<p>LDA 模型作为一个关于语料库的概率发生模型。它的基本思想是文档被表示为基于潜在主题的随机混合，其中每个主题由于基于词的分布不同而与众不同。</p>
<p>通过下面这张贝叶斯图，我们可以更好地理解LDA模型</p>
<p><img src="/images/old-resources/model 1.png" alt="model 1"></p>
<p>图中的框表示可重复执行的器件。外框表示的是文档，而内框表示对一篇文档内的主题和词的重复选择。</p>
<p>对于LDA模型，我们有如下定义：</p>
<ol>
<li>词语是离散数据中的基本单元，我们将其定义为{1, …, V}词库中的一员。我们通过这些基本单元的向量来表示词，在这些向量中，都只有一个元素为 1，其余都是 0。因此，我们采用上标字符来表示向量中的元素，词库中的第 v 个词语表示为一个长度为 V的向量w，向量中$w_v = 1，w_u = 0$，其中u ≠ v。</li>
<li>文档是一序列N个词，表示为$w = (w_1, w_2, …, w_N)$，其中$w_N$是这一序列中的第N个词</li>
<li>语料库是一个M个文档的集合，表示为$D = {\mathbf{w_1}, \mathbf{w_2}, …, \mathbf{w_M}}$</li>
<li>z表示为主题，主题数为K</li>
</ol>
<p>LDA为语料库D中的每个文档w假定以下生成过程</p>
<ol>
<li>$\alpha , \beta$ 分布为Dirichlet分布的先验参数，$\theta \sim Dir(\alpha), \phi \sim Dir(\beta)$</li>
<li>$\theta$为文档-主题的大学生分布，$\phi$为主题-词的多项式分布，其中的主题数为K</li>
<li>对于某一文档d中的一个词w，取主题$z \sim Multi(\theta_d)$， 生成对应词$w \sim Multi(\phi_z)$</li>
</ol>
<p>在构建模型的过程中，采用的是 Gibbs 采样的方法，通过一直迭代到收敛训练出最终的文档-主题分布θ、主题-词分布φ。</p>
<p>利用 LDA 模型，我们可以获得文档潜在主题的分布，并利用朴素贝叶斯分类器用这些信息实现对相同文档的匹配等。</p>
<h2 id="Gibbs-Sampling"><a href="#Gibbs-Sampling" class="headerlink" title="Gibbs Sampling"></a>Gibbs Sampling</h2><p>由于LDA中的主题z，文档-主题分布θ、主题-词分布φ都是未知的隐含变量，是需要根据观察到的文档集合中的词来学习估计的，所以不能通过最大似然估计的方法来确定主题分布，我们一般采用Gibbs Sampling的方法通过迭代得到文档-主题分布θ、主题-词分布φ。</p>
<p>Gibbs Sampling 是Markov-Chain Monte Carlo算法的一个特例。这个算法的运行方式是每次选取概率向量的一个维度，给定其他维度的变量值Sample当前维度的值。不断迭代，直到收敛输出待估计的参数。</p>
<p>换句话说，就是每一维度都是由其他维采样生成的，马氏链的转移只是轮流沿着该维度内的单条坐标轴进行转移，无法沿着单条坐标轴转移的，转移概率都设为0.</p>
<p>图示如下：</p>
<p><img src="/images/old-resources/14908762507727.jpg" alt=""></p>
<ol>
<li>初始时我们随机给文本中的每个单词分配主题$z^{(0)}$，</li>
<li>然后统计每个主题z下出现term t的数量以及每个文档 m 下出现主题 z 中的词的数量，每一轮计算 $p(z<em>i|\mathbf{Z}</em>{-i}, \mathbf{d}, \mathbf{w})$，即排除当前词的主题分配，根据其他所有词的主题分配估计当前词分配各个主题的概率。</li>
<li>当得到当前词属于所有主题z的概率分布后，根据这个概率分布为该词sample一个新的主题$z^{(1)}$。</li>
<li>然后用同样的方法不断更新下一个词的主题，直到发现每个文档下Topic分布$\mathbf{\theta_m}$和每个Topic下词的分布$\mathbf{\phi_k}$收敛，算法停止，输出待估计的参数$\mathbf{\theta_m}$和$\mathbf{\phi_k}$。</li>
<li>最终每个单词的主题也$z<em>{m,n}$同时得出。实际应用中会设置最大迭代次数。每一次计算$p(z_i|\mathbf{Z}</em>{-i}, \mathbf{d}, \mathbf{w})$的公式称为Gibbs updating rule。</li>
</ol>
<p>关于LDA模型通过Gibbs Sampling训练得到参数的具体数学公式推导，可以详见<a href="https://pdfs.semanticscholar.org/a166/d65a5d5a2905b038288e59c4fd98864c6f44.pdf">Distributed Gibbs Sampling of Latent Topic Models: The Gritty Details</a></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>训练得到LDA模型后，我们能够用这个模型做什么呢？在这里我简要介绍两种。</p>
<h3 id="计算文档的topic语义分布"><a href="#计算文档的topic语义分布" class="headerlink" title="计算文档的topic语义分布"></a>计算文档的topic语义分布</h3><p>我们认定，对于一个新的文档$d<em>{new}$，之前训练阶段得到的主题-词分布φ是不变的，可以通过这样的方法得到该文档中的文档-主题分布$\theta</em>{new}$</p>
<ol>
<li>对文档中的每个词随机赋予一个topic z</li>
<li>按照Gibbs Sampling的公司，对每个词重新采样它的topic</li>
<li>重复上述过程直到收敛</li>
<li>统计文档中的topic分布，得到该文档中的文档-主题分布$\theta_{new}$</li>
</ol>
<h3 id="文档匹配"><a href="#文档匹配" class="headerlink" title="文档匹配"></a>文档匹配</h3><p>我们可以用朴素贝叶斯分类器为新输入的文档找到与之前文档中最匹配的。</p>
<p>公式如下：</p>
<script type="math/tex; mode=display">
P(d|d_{new}) \propto P(d) P(d_{new} | d) = P(d) \prod_{w \in d_{new}} \sum_z \phi_{w|z} \theta_{z|d}</script><p>这里z表示topic。用这个贝叶斯公式，我们通过遍历所有的训练集，找到匹配概率最大的文档就是语义最相似的文档。</p>
<p>下一节我会简要介绍下我基于LDA模型的毕设和省创项目</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>NLP</category>
        <category>Topic Model</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>LDA</tag>
        <tag>主题模型</tag>
        <tag>贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈主题模型（二）—— 相关概率知识</title>
    <url>/2017/03/28/%E6%B5%85%E8%B0%88%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>承接“浅谈主题模型（一）”中的主题模型的历史，本文着重介绍LDA模型的相关概率知识，为接下来介绍LDA模型打下基础。<br><span id="more"></span></p>
<p>在LDA模型中，涉及到相当多的数学尤其是概率统计方面的知识，在具体介绍LDA模型之前，首先对这些概率知识进行一个总结归纳。</p>
<p>在LDA模型框架下，我们认为文本是一系列服从一定概率分布的词项的样本集合：每个文档中词的Topic分布服从Multinomial分布，其先验选取共轭先验即Dirichlet分布；每个Topic下词的分布服从Multinomial分布，其先验也同样选取共轭先验即Dirichlet分布。</p>
<p>接下来主要介绍Dirichlet分布以及其中涉及到的Gamma函数的相关知识。</p>
<h2 id="Gamma-函数"><a href="#Gamma-函数" class="headerlink" title="Gamma 函数"></a>Gamma 函数</h2><p>Gamma函数：</p>
<script type="math/tex; mode=display">
\Gamma(x) = \int_{0}^{\infty}{t^{x-1} e^{-t} dt}</script><p>通过分部积分的方法，可以推导出这个函数有着如下的递归性质：</p>
<script type="math/tex; mode=display">
\Gamma(x + 1) = x \Gamma(x)</script><p>可以证明得到，$\Gamma(x)$函数可以当成是阶乘在实数集上的延拓，具有如下性质：</p>
<script type="math/tex; mode=display">
\Gamma(n) = (n - 1)!</script><p>下面简要地介绍下gamma函数的一些应用</p>
<h3 id="求函数的分数阶导数"><a href="#求函数的分数阶导数" class="headerlink" title="求函数的分数阶导数"></a>求函数的分数阶导数</h3><p>Gamma 函数可以用于求分数阶导数：</p>
<p>对于 $x^n$ 的各阶导数：</p>
<p>first derivative： $n x^{n - 1}$</p>
<p>second derivative： $n (n - 1) x^{n - 2}$</p>
<p>···</p>
<p>k-th derivative： $ \frac{n!}{(n - k)!} x^{n - k}$</p>
<p>由于k阶导数可以用阶乘表示，于是我们用Gamma函数表达为：</p>
<script type="math/tex; mode=display">
\frac{\Gamma(n + 1)}{\Gamma(n - k + 1)} x^{n - k}</script><p>k可以表示为分数，即可求得分数阶导数。</p>
<h3 id="Bohr-Mullerup-定理"><a href="#Bohr-Mullerup-定理" class="headerlink" title="Bohr-Mullerup 定理"></a>Bohr-Mullerup 定理</h3><p>若$f: (0,\infty) \rightarrow (0,\infty)$ 且满足：</p>
<ol>
<li>$f(1) = 1$</li>
<li>$f(x + 1) = xf(x)$</li>
<li>$\log {f(x)}$ 是凸函数</li>
</ol>
<p>那么$f(x) = \Gamma(x)$</p>
<h3 id="Digamma-函数"><a href="#Digamma-函数" class="headerlink" title="Digamma 函数"></a>Digamma 函数</h3><script type="math/tex; mode=display">
\Psi(x) = \frac{d \log{\Gamma(x)}}{dx}</script><p>Digamma函数在涉及求Dirichlet分布相关的参数的极大似然估计时，往往要用到。</p>
<p>Digamma函数具有以下性质：</p>
<script type="math/tex; mode=display">
\Psi(x + 1) = \Psi(x) + \frac{1}{x}</script><h3 id="Gamma-分布"><a href="#Gamma-分布" class="headerlink" title="Gamma 分布"></a>Gamma 分布</h3><p>对gamma函数的定义做一个变形：</p>
<script type="math/tex; mode=display">
\int _0^{\infty} \frac{x^{\alpha - 1} e^{-x}}{\Gamma(\alpha)}dx = 1</script><p>将积分部分视为概率密度，得到Gamma分布密度函数</p>
<script type="math/tex; mode=display">
Gamma(x|\alpha) = \frac{x^{\alpha - 1} e^{-x}}{\Gamma(\alpha)}</script><p>$x = \beta t$得到一个一般形式：</p>
<script type="math/tex; mode=display">
Gamma(t|\alpha, \beta) = \frac{\beta^{\alpha}t^{\alpha - 1} e^{-\beta x}}{\Gamma(\alpha)}</script><p>在实际应用中， 指数分布和$\chi^2$分布都是特殊的Gamma分布</p>
<h2 id="Dirichlet-分布"><a href="#Dirichlet-分布" class="headerlink" title="Dirichlet 分布"></a>Dirichlet 分布</h2><p>如果说要用一句话来简要介绍Dirichlet分布的话，那就是分布之上的分布。下面从Beta分布来引入对Dirichlet分布的介绍。</p>
<h3 id="Beta-分布"><a href="#Beta-分布" class="headerlink" title="Beta 分布"></a>Beta 分布</h3><p>用一个比较实际的情况来解释beta分布：</p>
<ol>
<li>$X_1,X_2,…,X_n \sim Uniform(0,1)$</li>
<li>把这n个随机变量排序，$X_{(k)}$的分布式Beta分布</li>
</ol>
<p>如何确定？</p>
<p>通过计算$X_{k}$落在一个区间$[x, x + \Delta x]$的概率，其中$[0,x)$有 k-1 个数， $(x,1]$有n-k 个数</p>
<script type="math/tex; mode=display">
\begin{eqnarray} \nonumber
P(E) & = & \prod_{i = 1}^{n} P(X_i) \\ \nonumber
& = & x^{k-1} (1 - x - \Delta x)^{n - k} \Delta x \\
& = & x^{k - 1}(1 - x)^{n - k}\Delta x + o(\Delta x) \nonumber
\end{eqnarray}</script><script type="math/tex; mode=display">
\begin{eqnarray} \nonumber
P(x \leq X_{k} \leq x + \Delta x) & = & n \begin{pmatrix}n - 1 \\ k -1 \end{pmatrix} P(E) + o(\Delta x) \\ \nonumber
& = & n \begin{pmatrix}n - 1 \\ k -1 \end{pmatrix} x^{k - 1} (1-x)^{n - k}\Delta x + o(\Delta x) \nonumber 
\end{eqnarray}</script><p>$X_{k}$的概率密度函数为</p>
<script type="math/tex; mode=display">
\begin{eqnarray} \nonumber
f(x) & = & \lim_{\Delta x \rightarrow 0}\frac{P(x \leq X_{k} \leq x + \Delta x)}{\Delta x} \\ \nonumber
& = & n \begin{pmatrix}n - 1 \\ k -1 \end{pmatrix} x^{k - 1} (1-x)^{n - k}\\
& = & \frac{n !}{(k-1)!(n-k)!} x^{k - 1} (1-x)^{n - k} \nonumber
\end{eqnarray}</script><p>利用gamma函数，可以表示为</p>
<script type="math/tex; mode=display">
f(x) =\frac{\Gamma(n+1)}{\Gamma(k)\Gamma(n-k+1)} x^{k - 1} (1-x)^{n - k}</script><p>取$\alpha = k$, $\beta = n - k + 1$</p>
<script type="math/tex; mode=display">
f(x) = \frac{\Gamma(\alpha + \beta)}{\Gamma(\alpha) \Gamma(\beta )} x^{\alpha - 1}(1- x)^{\beta - 1}</script><p>即是beta分布。</p>
<h3 id="Beta-Binomial-共轭"><a href="#Beta-Binomial-共轭" class="headerlink" title="Beta-Binomial 共轭"></a>Beta-Binomial 共轭</h3><p>用一个比较实际的情况来解释Beta-Binomial共轭：</p>
<ol>
<li>$X<em>1,X_2,…,X_n \sim Uniform(0,1)$ ，排序后对应顺序统计量$X</em>{(1)}, X<em>{(2)}, … ， X</em>{(n)} $我们要猜测 $p = X_{(k)}$</li>
<li>$Y_1, Y_2, …, Y_m \sim Uniform(0,1), Y_i$中有$m_1$个比p小，$m_2$个比p大</li>
<li>问$P(p|Y_1, Y2, …, Y_m)$ 的分布是什么。</li>
</ol>
<p>根据beta分布，上面情况中的 1 可以推导出 p 的分布为Beta分布 $f(p) = Beta(p|k, n - k + 1)$，也称为p的先验分布</p>
<p>根据上述中的 2， 相当于是做了m次伯努利实验，所以 $ m_1 $服从二项分布</p>
<p>在给定了来自数据提供的 $(m_1 ,  m_2)$知识后，p的后验分布变为 $f(p|m_1, m_2) = Beta(p|k+m_1, n - k + 1 + m_2)$</p>
<p>根据贝叶斯参数估计的基本过程：</p>
<script type="math/tex; mode=display">
先验分布 + 数据知识 = 后验分布</script><p>以上贝叶斯分析的简单直观的表述就是</p>
<script type="math/tex; mode=display">
Beta(p|k, n - k + 1) + BinomCount(m_1, m_2) = Beta(p|k+m_1, n - k + 1 + m_2)</script><p>所以Beta-Binomial共轭式为：</p>
<script type="math/tex; mode=display">
Beta(p|\alpha, \beta) + BinomCount(m_1,m_2) = Beta(p|\alpha + m_1, \beta + m_2)</script><p>此处共轭的意思就是数据符合二项分布的时候，参数的先验分布和后验分布都能保持Beta分布的形式。</p>
<h3 id="Dirichlet-Multinomial-共轭"><a href="#Dirichlet-Multinomial-共轭" class="headerlink" title="Dirichlet - Multinomial 共轭"></a>Dirichlet - Multinomial 共轭</h3><p>首先我们需要先了解下什么是Dirichlet分布</p>
<p>用一个比较实际的情况来解释Dirichlet分布：</p>
<ol>
<li>$X_1,X_2,…,X_n \sim Uniform(0,1)$ </li>
<li>排序后对应顺序统计量$X<em>{(1)}, X</em>{(2)}, … ， X_{(n)} $</li>
<li>问$(X<em>{(k_1)}, X</em>{(k_1 + k_2)})$ 的联合分布是什么。</li>
</ol>
<p>通过类似Beta分布的推导，我们可以得到联合分布为：</p>
<script type="math/tex; mode=display">
\begin{eqnarray} \nonumber
f(x_1,x_2,x_3) & = & \frac{n!}{(k_1 - 1)!(k_2 - 1)!(n - k_1 - k_2)!}x_1^{k_1 - 1}x_2^{k_2 - 1}x_3^{n - k_1 - k_2}  \\ \nonumber
& = & \frac{\Gamma (n + 1)}{\Gamma (k_1)\Gamma (k_2)\Gamma (n - k_1 - k_2 + 1)}x_1^{k_1 - 1}x_2^{k_2 - 1}x_3^{n - k_1 - k_2} \\  \nonumber
\end{eqnarray}</script><p>该分布就是3维形式的Dirichlet分布，令$\alpha<em>1 = k_1, \alpha_2 = k_2, \alpha_3 = n - k</em>! - k_2 + 1$，概率密度可以写成：</p>
<script type="math/tex; mode=display">
f(x_1,x_2,x_3) = \frac{\Gamma (\alpha_1 + \alpha_2 + \alpha_3)}{\Gamma (\alpha_1)\Gamma (\alpha_2)\Gamma (\alpha_3)}x_1^{\alpha_1 - 1}x_2^{\alpha_2 - 1}x_3^{\alpha_3 - 1}</script><p>Dirichlet分布，其参数是两个标量：维数K和参数向量各维均值$\alpha = \frac{\sum \alpha_l}{K}$ 其分布律的一般形式为：</p>
<script type="math/tex; mode=display">
p(p^{\rightarrow} | \alpha, K) = Dir(p^{\rightarrow} | \alpha, K) = \frac{\Gamma(K \alpha)}{\Gamma(\alpha)^K} \prod_{k = 1}^K p_k^{\alpha - 1} = \frac{1}{\Delta_k(\alpha)} \prod_{k = 1}^K p_k^{\alpha - 1}</script><script type="math/tex; mode=display">
\Delta_k(\alpha) = \frac{\Gamma(\alpha)^K}{\Gamma(K\alpha)}</script><p>那么什么是Dirichlet - Multinomial 共轭呢？</p>
<p>用一个比较实际的情况来解释Dirichlet - Multinomial 共轭：</p>
<ol>
<li>$X<em>1,X_2,…,X_n \sim Uniform(0,1)$ ， 排序后对应顺序统计量$X</em>{(1)}, X<em>{(2)}, … ， X</em>{(n)} $</li>
<li>令$p<em>1 = X</em>{(k<em>1)}$， $p_2 = X</em>{(k_1 + k_2 )}$， $p_3 = 1 - p_1 - p_2 $， 我们要猜测 $p^{\rightarrow} = (p_1, p_2, p_3 )$</li>
<li>$Y_1, Y_2, …, Y_m \sim Uniform(0,1), Y_i$中落到[$0, p_1 $), [$p_1 , p_2 $), [$p_2 , 1$) 三个区间的个数分别为 $m_1, m_2, m_3, m = m_1 + m_2 + m_3$</li>
<li>问后验分布$P(p^{\rightarrow} | Y_1, Y_2, … , Y_m)$ 的分布是什么。</li>
</ol>
<p>以上贝叶斯分析的简单直观的表述就是</p>
<script type="math/tex; mode=display">
Dir(p^{\rightarrow} | k^{\rightarrow}) + MultCount(m^{\rightarrow }) = Dir(p^{\rightarrow} | k^{\rightarrow} + m^{\rightarrow})</script><p>描述的就是Dirichlet - Multinomial 共轭</p>
<p>下一节将开始介绍LDA模型</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>NLP</category>
        <category>Topic Model</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>LDA</tag>
        <tag>主题模型</tag>
        <tag>贝叶斯</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈主题模型（一） —— 主题模型进化史</title>
    <url>/2017/03/28/%E6%B5%85%E8%B0%88%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>本科阶段，我用NLP的方法处理从网上健康社区爬取下来的问答数据，通过主题模型的构建实现了对患者提问的答案以及专家的智能化匹配过程。本文及以后的一系列“浅谈主题模型”主要谈谈主题模型的历史，着重介绍下LDA模型，同时也对自己曾经的项目做一个总结概括。<br><span id="more"></span></p>
<p>在自然语言处理中，一个非常重要的步骤就是word embedding，即将词转为向量的过程。而主题模型在本质上也是一种将词转为向量的方法。本块主要介绍主题模型的发展历程并分析各个模型的优劣之处。</p>
<h2 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h2><p>早在上世纪 80 年代，研究者们常常使用 TF-IDF 法来进行文档的检索和信息的提取。</p>
<p>在 TF-IDF 方法中，先选择一个基于词或者词组的基本词汇，然后对于语料库中的每个文档，分别统计其中每个单词的出现次数。经过合适的正则化后，再将词的频率计数和反向文档频率计数相比较，得到一个词数乘以文档数的向量 X。向量的每个行中都包含着语料库中每个文档的 TF-IDF 值。</p>
<p>IF 和 IDF 的概念见下：</p>
<script type="math/tex; mode=display">
tf_{i,j}=\frac {n_{i,j}}{\sum_k n_{k,j}}</script><p>其中$if_{i,j}$是该词在文件$d_j$中出现的次数，分母表示文件$d_j$中所有字词的出现次数之和。</p>
<script type="math/tex; mode=display">
idf_i =\log \frac {|D|}{|\{j:t_i \in d_j\}|}</script><p>|D|是语料库中的文件总数<br>$|{j:t_i \in d_j}|$ 表示包含词语 $t_i$ 的文件数目。如果词语不在语料库中，为了避免分母为零的情况，一般会加上1.</p>
<script type="math/tex; mode=display">
tfidf_{i,j} = tf_{i,j} \times idf_{i,j}</script><p>对于某一特定文件中的高频词语，如果含有该词语的文档在整个文件集中是低频的，则我们可以得到一个较大的TF-IDF的值。因此，TF-IDF倾向于过滤去常见的词语，保留重要的词语。</p>
<p>但是整个TF-IDF算法是建立在一个假设之上的：一个单词出现的文本频数越小，它区别不同类别文本的能力就越大。这个假设很多时候是不正确的，尤其是在引入IDF的过程中，单纯地认为文本频率小的单词就越重要，文本频率大的单词就越无用，显然这并不是完全正确的。其也不能有效地反映单词的重要程度和特征词的分布情况，因此精度有限。</p>
<h2 id="LSA-隐形语言分析"><a href="#LSA-隐形语言分析" class="headerlink" title="LSA 隐形语言分析"></a>LSA 隐形语言分析</h2><p>如果说TF-IDF算法体现的是文档中词出现的频率的情况，那么LSA则更进了一步，其目的是为了从文本中发现隐含的topic。</p>
<p>在文档的空间向量模型中，文档被表示成由特征词出现概率组成的多维向量，这种方法可以通过对不同词赋予不同的权重，应用于文本检索、分类以及聚类等问题中。然而这种空间向量模型没有能力处理一词多义以及一义多词这类问题。同义词也分别被表示成独立的一维，计算向量的余弦相似度时会低估用户期望的相似度，而某个词项有多个词义时，始终对应同一维度，因此计算的结果会高估用户期望的相似度。</p>
<p>而LSA的方法就减轻了类似的问题。LSA使用矩阵的奇异值分解来确定一个在 TF-IDF 特征空间中的线性子空间，实现大幅压缩以及对同义和一词多义等基本语言概念的捕捉。</p>
<p>通过SVD分解，我们可以构造一个原始向量矩阵的一个低秩逼近矩阵，具体的做法是将词项文档矩阵做SVD分解：</p>
<script type="math/tex; mode=display">
C = U\Sigma V^T</script><p>其中C是以词为行，文档为列的矩阵，设一共有t行d列,  矩阵的元素为词项的TF-IDF值。然后把 $\Sigma$ 的r个对角元素的前k个保留（最大的k个保留）, 后面最小的r-k个奇异值置0, 得到 $\Sigma_k$ ；最后计算一个近似的分解矩阵</p>
<script type="math/tex; mode=display">
C_k = U\Sigma_kV^T</script><p>$C_k$ 在最小二乘意义下是C的最佳逼近。由于 $\Sigma_k$ 最多包含k个非零元素，所以 $C_k$ 的秩不超过k。通过在SVD分解近似，我们将原始的向量转化成一个低维隐含语义空间，起到了特征降维的作用。每个奇异值对应的是每个“语义”维度的权重，将不太重要的权重置为0，只保留最重要的维度信息，去掉一些信息 “nosie”，因而可以得到文档的一种更优表示形式。</p>
<p><img src="/images/old-resources/14902797703583.jpg" alt=""></p>
<p><img src="/images/old-resources/14902799008348.jpg" alt=""></p>
<p>上图是原始矩阵的SVD分解，下图是只保留权重最大2维，将原始矩阵降到2维后的情况。</p>
<h2 id="pLSA-潜在语义索引概率模型"><a href="#pLSA-潜在语义索引概率模型" class="headerlink" title="pLSA 潜在语义索引概率模型"></a>pLSA 潜在语义索引概率模型</h2><p>尽管基于SVD的LSA取得了一定的成功，但是其缺乏严谨的数理统计基础，而且SVD分解非常耗时。Hofmann在SIGIR’99上提出了基于概率统计的PLSA模型，并且用EM算法学习模型参数。PLSA的概率图模型如下</p>
<p><img src="/images/old-resources/14902803695129.jpg" alt=""></p>
<p>其中D代表文档，Z代表隐含类别或者主题，W为观察到的单词，$P(d_i)$表示单词出现在文档的概率，$P(z_k|d_i) $表示文档$d_i$中出现主题$z_k$下的单词的概率，$P(w_j|z_k)$给定主题$z_k$出现单词$w_j$的概率。并且每个主题在所有词项上服从Multinomial分布，每个文档在所有主题上服从Multinomial 分布。整个文档的生成过程是这样的：<br>(1) 以$P(d_i)$的概率选中文档$d_i$；<br>(2) 以$P(z_k|d_i)$的概率选中主题$z_k$；<br>(3) 以$P(w_j|z_k)$的概率产生一个单词$w_j$。<br>我们可以观察到的数据就是$(d_i, w_j)$对，而$z_k$是隐含变量。$(d_i, w_j)$的联合分布为:</p>
<script type="math/tex; mode=display">
P(d_i,w_j) = P(d_i)P(w_j|d_i), P(w_j|d_i) = \sum_{k = 1}^{K}P(w_j|z_k)P(z_k|d_i)</script><p>而$P(z_k|d_i)$和 $P(w_j|z_k)$分别对应了两组Multinomial分布，我们需要估计这两组分布的参数，一般是用EM算法来估算出pLSA的参数。关于EM算法可以详见<a href="http://tianyuh.com/2017/03/08/%E4%BB%8EEM%E7%AE%97%E6%B3%95%E5%88%B0GMM%E6%A8%A1%E5%9E%8B/">从EM算法到GMM模型</a>一文。在此不做推导证明，只列出最终答案：</p>
<script type="math/tex; mode=display">
P(w_j|z_k) = \frac{\sum_{i = 1}^{N}n(d_i,w_j)P(z_k|d_i,wj)}{\sum_{m = 1}^{M}{\sum_{i = 1}^{N}n(d_i,w_j)P(z_k|d_i,w_m)}}</script><script type="math/tex; mode=display">
P(z_k|d_i) = \frac{\sum_{j = 1}^{M}n(d_i,w_j)P(z_k|d_i,wj)}{n(d_i)}</script><p>如此不断在E-step和M-step中迭代，直到满足终止条件。（具体的参考过程可以详见这篇<a href="http://blog.csdn.net/yangliuy/article/details/8330640">博文</a>）</p>
<p>pLSA将文档中的每个词建模为一个来自混合模型的样本。这个混合模型中的成分是可以被看作“主题”的多项式随机变量。因此每个词都是由单一一个主题产生的，文档中不同的词语可以由不同的主题产生的。每篇文档可以表示为各种主题按照一定比例的混合，成为主题集下的分布。尽管 Hofmann 的成果对于主题概率模型是具有启发性的，但是在 pLSA 模型中，Hofman 仅仅将文档——主题、主题——词的分布视为参数而非随机变量。这使得模型中的参数数目和语料库呈线性关系，最终会导致由于语料库的增大导致过拟合，此外其也缺乏对训练集以外的文档的理论支持。</p>
<h2 id="LDA-Latent-Dirichlet-Allocation"><a href="#LDA-Latent-Dirichlet-Allocation" class="headerlink" title="LDA (Latent Dirichlet Allocation)"></a>LDA (Latent Dirichlet Allocation)</h2><p>David Blei在2003年提出了LDA（Latent Dirichlet Allocation）的概念，对pLSA模型进行了贝叶斯拓展，利用一种层级贝叶斯模型构建了LDA模型，通过把模型的参数看作随机变量，引入控制参数的参数，实现模型概率化，避免同pLSA那样随着语料库的增大而出现过拟合现象。</p>
<p>下下节中会对LDA进行简要的介绍。</p>
<p>自从LDA的概念提出以来，主题模型已经在诸多文本挖掘的领域取得了令人瞩目的成果。主题概率模型不同于以往的空间向量模型（以TF-IDF为例）和语言模型（n-gram 等），它通过主题在词上的概率分布将主题引入文档中，再将文档视为主题的概率分布，从而分析出文档内潜在的主题。主题概率模型的优越性不仅仅体现在其能够分析出文档中的潜在主题，更在于通过主题概率模型，我们能够显著地降低文档特征的维度。相比较于TFIDF中词→文档，主题概率模型通过词→主题→文档将词与文档隔离开，由于主题个数远远小于词数，实现降维的过程。这种显著的降维可以使得针对大数据的分析操作有了实践基础，拥有了更低的训练模型成本。同时更低的维度也将数据自身的噪声影响降得更低，使得训练的结果更加优秀。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>NLP</category>
        <category>Topic Model</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>主题模型</tag>
        <tag>贝叶斯</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>Bag of Words for Image Classification</title>
    <url>/2017/03/22/Bag-of-Words-for-Image-Classification/</url>
    <content><![CDATA[<p>最近了解到了一种很有意思的关于图像分类的算法，用bag of words的思想来对图像进行处理，很巧妙地将原本是图像处理的问题变换成了自然语言处理的问题。本文将简要对这种方法进行介绍。<br><span id="more"></span></p>
<h2 id="Bag-of-Words-BoW-词袋模型原理"><a href="#Bag-of-Words-BoW-词袋模型原理" class="headerlink" title="Bag of Words (BoW) 词袋模型原理"></a>Bag of Words (BoW) 词袋模型原理</h2><p>Bag of words model (BoW model) 最早出现在NLP和IR领域。该模型将一段文字视为一系列无序的单词，忽略掉文本的语法和语序。近年来，BoW模型被广泛应用于计算机视觉中。与应用于文本的BoW类比，图像的特征被当作单词。</p>
<p>在BoW中，我们统计的是一个词在一份文档中出现的次数，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) John likes to watch movies. Mary likes movies too.</span><br><span class="line">(2) John also likes to watch football games.</span><br></pre></td></tr></table></figure>
<p>中有10个不同的词，分别可以被构建为一个如下的向量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) [1, 2, 1, 1, 2, 0, 0, 0, 1, 1] </span><br><span class="line">(2) [1, 1, 1, 1, 0, 1, 1, 1, 0, 0] </span><br></pre></td></tr></table></figure>
<p>在邮件过滤中，这种方法有着很好地应用。</p>
<p>在<a href="https://tianyuh.com/2017/03/28/%E6%B5%85%E8%B0%88%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/">浅谈主题模型</a>中，我所介绍的TF-IDF在本质上也是一种BoW模型，不同在于加上了Term Weighting。</p>
<h2 id="提取图像特征"><a href="#提取图像特征" class="headerlink" title="提取图像特征"></a>提取图像特征</h2><p>机器学习的第一步也是最重要的一步就是提取特征，这关乎到随后一系列工作中数据的质量问题。在BoW处理图像的过程中，我们可以用Filter Bank或是SIFT等方法来提取</p>
<h3 id="Filter-Bank"><a href="#Filter-Bank" class="headerlink" title="Filter Bank"></a>Filter Bank</h3><p>用不同的滤波器对图像进行滤波，得到一系列滤波处理后的图片，随机选取一些pixel，组成一列，然后将所有滤波后的图片一起组成一个矩阵。矩阵中每个元素的值是rgb三值。以此构成的矩阵中的每一行是一个特征向量。</p>
<p>本文下述的相关操作都是基于filter bank的方法来做的。</p>
<h3 id="SIFT"><a href="#SIFT" class="headerlink" title="SIFT"></a>SIFT</h3><p>SIFT特征虽然也能描述一幅图像，但是每个SIFT矢量都是128维的，而且一幅图像通常都包含成百上千个SIFT矢量，在进行相似度计算时，这个计算量是非常大的，通行的做法是用聚类算法对这些矢量数据进行聚类，然后用聚类中的一个簇代表BoW中的一个视觉词，将同一幅图像的SIFT矢量映射到视觉词序列生成码本，这样每一幅图像只用一个码本矢量来描述，这样计算相似度时效率就大大提高了。</p>
<p>在BoW中我们对每一幅图像提取SIFT特征（每一幅图像提取多少个SIFT特征不定）。每一个SIFT特征用一个128维的描述子矢量表示。每一个SIFT特征即为特征向量。</p>
<h2 id="构建词库"><a href="#构建词库" class="headerlink" title="构建词库"></a>构建词库</h2><p>创建完特征向量后，我们需要将特征向量和词对应起来（map to words）。</p>
<p>我们可以用k-means的方法对特征向量进行聚类，用欧氏距离表示cluster和特征点之间的距离，通过多次迭代得到的每个cluster就是词。因此我们在进行k-mean的时候要仔细确定好词的数量，太多的词会导致过拟合而太少的词会出现欠拟合现象。</p>
<p>完成这一步后，我们就构建完成了一个词库，接下来就要在图像中表现出这些词。</p>
<p>下图为一些出现的高频“词”</p>
<p><img src="/images/old-resources/14901949601534.jpg" alt=""></p>
<h2 id="图像中词的直方图分布（Visual-Words）"><a href="#图像中词的直方图分布（Visual-Words）" class="headerlink" title="图像中词的直方图分布（Visual Words）"></a>图像中词的直方图分布（Visual Words）</h2><p>对于图像中的每个点，用欧式距离法判断属于哪个词，从而得到图像中词的一个直方图分布。下图表示的是visual word的信息。</p>
<p><img src="/images/old-resources/14901947887360.jpg" alt=""></p>
<p>为了不完全抛弃图中pixel的位置，我们还可以采用spacial pyramid matching的方法来保留一部分spacial information（表现在所取的每个patch中）</p>
<p><img src="/images/old-resources/14901945203509.jpg" alt=""></p>
<p>此外，我们甚至可以将TF-IDF的思想引入其中，得到具体的值，在test的过程中通过内积来做相似性度量。</p>
<h2 id="KNN进行图像分类（testing）"><a href="#KNN进行图像分类（testing）" class="headerlink" title="KNN进行图像分类（testing）"></a>KNN进行图像分类（testing）</h2><p>将training set中的每个直方图分布视为一个vector，先获取testing set中的一幅图的直方图分布，比较和training set中图的距离，找出最近的k个点中所对应training image的对应分类即是该图的分类结果。</p>
<p><img src="/images/old-resources/14901944615694.jpg" alt=""></p>
<p>需要注意的一点是，k的取值不能太大，尤其是当某一类中的图片较少时更是如此。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Computer Vision</category>
      </categories>
      <tags>
        <tag>image processing</tag>
        <tag>BoW</tag>
        <tag>algorithm</tag>
        <tag>classification</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep Learning Chapter 2</title>
    <url>/2017/03/09/Deep-Learning-Chapter-2/</url>
    <content><![CDATA[<p>在Deep Learning一书的第二章，主要介绍了线性代数的基本思想。</p>
<span id="more"></span>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>标量：单独的数</p>
<p>向量：一列数</p>
<p>矩阵：二维数组</p>
<p>张量：多维数组</p>
<p>在深度学习中，我们有时允许矩阵和向量相加，产生另一个矩阵：<br>$\mathbf{C} = \mathbf{A} + \mathbf{b} $，其中 $C<em>{i,j} = A</em>{i,j} + b_j$， 即向量b和矩阵A的每一行相加。</p>
<p>矩阵中元素对应的乘积表示为： $\mathbf{A \odot B}$</p>
<p>同时需要注意的一点是，只有非奇异的方阵才有逆。所谓非奇异也就是说，方阵的所有列向量都是线性无关的。一个列向量线性相关的方阵被称为奇异的。</p>
<h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><p>$L^p$ 范数的定义如下：</p>
<script type="math/tex; mode=display">
\left \| \mathbf{x} \right \|_p = (\sum_i{|x_i|^p})^{\frac{1}{p}}</script><p>范数是将向量映射到非负值的函数。向量x的范数是衡量从原点到点x的距离。其需要满足下列三个条件：</p>
<ol>
<li>$f(\mathbf{x}) = 0 \Rightarrow \mathbf{x} = \mathbf{0}$</li>
<li>$f(\mathbf{x} + \mathbf{y}) \geq f(\mathbf{x}) + f(\mathbf{y})$ (三角不等式)</li>
<li>$ \forall \alpha \in \mathbb{R}, f(\alpha \mathbf{x}) = |\alpha| f(\mathbf{x}) $</li>
</ol>
<p>p = 2时，$L^2$被称为欧几里得范数，表示的是原点和x之间的欧氏距离。</p>
<p>平方$L^2$范数： $\mathbf{x}^T x$。</p>
<p>平方$L^2$范数较之$L^2$范数更加的方便，因为前者的导数只和对应元素相关，而后者的导数却是和整个向量相关。</p>
<p>但是有时我们仍然会遇到在原点附近增长缓慢的情况，对于一些区分零和非零小值的机器学习应用而言是十分致命的。因此很多时候会采用$L^1$范数，每当x中的某一元素增加了一个小量时，对应的防暑也会增加这个小量。</p>
<p>深度学习中，我们有时为了衡量矩阵的大小，使用类似$L^2$范数的Frobenius范数：</p>
<script type="math/tex; mode=display">
\left \| \mathbf{A} \right \|_F = \sqrt{\sum_i{A_{i,j}^2}}</script><h2 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h2><p>正交矩阵是指行向量和列向量都是<strong>标准正交</strong>的方阵：</p>
<script type="math/tex; mode=display">
\mathbf{A}^T \mathbf{A} = \mathbf{A} \mathbf{A}^T = \mathbf{I}</script><p>即：</p>
<script type="math/tex; mode=display">
\mathbf{A}^{-1} = \mathbf{A}^T</script><p>由于正交矩阵的求逆计算代价很小，所以在机器学习中经常得到运用</p>
<h2 id="特征分解"><a href="#特征分解" class="headerlink" title="特征分解"></a>特征分解</h2><p>所谓特征分解就是讲矩阵分解为一组特征向量和特征值。<br>方阵<strong>A</strong>的特征向量是指与<strong>A</strong>相乘后等于对该向量进行缩放的非零向量<strong>v</strong>：（我们一般只考虑单位特征向量）</p>
<script type="math/tex; mode=display">
\mathbf{A v} = \lambda \mathbf{v}</script><p>其中的标量λ被称为这个特征向量对应的特征值。</p>
<p>假设矩阵<strong>A</strong>有n个线性无关的特征向量${\mathbf{v^1},…,\mathbf{v^n}}$，对应着特征值${\lambda_1,…\lambda_n}$，我们将特征向量连接为一个矩阵，使得每一列是一个特征向量：$\mathbf{V} = {\mathbf{v^1},…,\mathbf{v^n}}$，将特征向量连接成一个向量$\mathbf{\lambda} = {\lambda_1,…\lambda_n}^T$<br>A的特征分解：</p>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{V} diag(\mathbf{\lambda})\mathbf{V}^{-1}</script><p>但是，不是每一个矩阵都可以分解为特征值和特征向量的。只有实对称矩阵才可以分解为实特征向量和实特征值，但是分解结果可能不唯一。如果两个或多个特征向量拥有相同的特征值，那么这组特征向量生成子空间中，任意一组正交向量都是该特征值对应的特征向量。</p>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{Q} \Lambda \mathbf{Q}^{T}</script><p>上式中Q是A的特征向量组成的正交矩阵，$\Lambda$是对角矩阵。因为Q是正交矩阵，我们可以将A看作是沿方向$\mathbf{v}^{i}$延展$\lambda_i$倍的空间</p>
<p><img src="/images/old-resources/Screen Shot 2017-03-14 at 12.54.28 AM.png" alt="Screen Shot 2017-03-14 at 12.54.28 A"></p>
<h2 id="奇异值分解-SVD"><a href="#奇异值分解-SVD" class="headerlink" title="奇异值分解 SVD"></a>奇异值分解 SVD</h2><p>奇异值分解也是一种分解矩阵的方法，将矩阵分解为奇异向量和奇异值，可以得到一些类似特征分解的信息。</p>
<p>SVD的应用更广，对于没有特征分解的非方阵矩阵，只能使用奇异值分解。</p>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{U D V}^T</script><p>U和V都是正交矩阵，D是对角矩阵。</p>
<p>矩阵U的列向量是左奇异向量，是$\mathbf{A} \mathbf{A}^T$的特征向量<br>矩阵V的列向量是右奇异向量，是$\mathbf{A}^T \mathbf{A}$的特征向量</p>
<p>SVD主要用于拓展矩阵求逆到非方矩阵上。</p>
<h2 id="Moore-Penrose-伪逆"><a href="#Moore-Penrose-伪逆" class="headerlink" title="Moore-Penrose 伪逆"></a>Moore-Penrose 伪逆</h2><p>非方矩阵的逆矩阵没有定义，对于下列的问题我们希望可以用矩阵A的左逆B来求解线性方程。</p>
<script type="math/tex; mode=display">
\mathbf{A x} = \mathbf{y}</script><script type="math/tex; mode=display">
\mathbf{x} = \mathbf{B y}</script><p>如果矩阵A的行数大于列数，那么上述方程可能没有解。如果矩阵A的行数小于列数，那么上述矩阵可能有多个解。</p>
<p>Moore-Penrose 伪逆定义：</p>
<script type="math/tex; mode=display">
\mathbf{A}^+ = \lim_{a \rightarrow 0}(\mathbf{A}^T \mathbf{A} + \alpha \mathbf{I})^{-1} \mathbf{A}^T</script><script type="math/tex; mode=display">
\mathbf{A}^+ = \mathbf{V} \mathbf{D}^+ \mathbf{U}^T</script><p>其中矩阵U、D、V是由A奇异值分解后得到的矩阵，对角矩阵D的伪逆$\mathbf{D}^+$是其所有非零元素取导数之后再转置得到的。</p>
<h2 id="PCA-应用"><a href="#PCA-应用" class="headerlink" title="PCA 应用"></a>PCA 应用</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>读数笔记</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>从EM算法到GMM模型</title>
    <url>/2017/03/08/%E4%BB%8EEM%E7%AE%97%E6%B3%95%E5%88%B0GMM%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>最近温习了下机器学习经典算法之一的EM算法，顺便对GMM模型有了更加深入的理解，本文将对这两个概念进行简要介绍。<br><span id="more"></span></p>
<h2 id="最大似然估计（MLE）"><a href="#最大似然估计（MLE）" class="headerlink" title="最大似然估计（MLE）"></a>最大似然估计（MLE）</h2><p>Maximum Likelihood Estimation</p>
<p>在介绍EM算法之前，不得不提最大似然估计。</p>
<p>最大似然估计可以解释为：</p>
<ol>
<li>假设 $ p (x | \omega) $ 是一个有参数向量 $\theta $ 唯一确定的概率分布</li>
<li>参数 $\theta $ 是固定但是未知的。</li>
<li>假设我们有一个按照概率分布 $ p (x | \omega) $ 的数据集 D，D 中的样本彼此独立。</li>
<li>MLE 就是 $\theta $ 的一个最能解释描述该数据集的值。</li>
</ol>
<p>我们也可以通俗地解释为：</p>
<p>最大似然估计一般用于求分布参数 $\theta $ : 给定一个概率分布，我们从概率分布中抽n个值的采样，通过这些采样数据来估计概率分布的参数 $\theta $，定义似然函数如下所示：</p>
<script type="math/tex; mode=display">
\begin{eqnarray}
lik(\theta ) & = & f_{D}(x_{1},x_{2},...,x_{n} | \theta ) \\
& = & \prod_{k = 1}^{N}p(x_k| \theta ))
\end{eqnarray}</script><script type="math/tex; mode=display">
\theta' = \arg \max_{\theta }\{p(Data|\theta )\}</script><p>在 $\theta $ 的所以取值上令一阶导数等于0，使得这个函数取到最大值，这个使可能性最大的 $ \theta ‘ $ 值即为 $\theta $ 的最大似然估计。</p>
<p>最大似然估计是建立在这样的思想上：已知某个参数能使这个样本出现的概率最大，我们就把这个参数作为估计的真实值。</p>
<p>那么我们要如何来解决ML estimate的问题呢？</p>
<ol>
<li>我们先设 $\mathbf{\theta }$ 为一个p元素的向量 $\mathbf{\theta } = [\theta_1,\theta_2,…,\theta_p]^T$</li>
<li>让其成为梯度算子 $ \bigtriangledown_\theta =[\frac{\partial }{\partial \theta_1}, \frac{\partial }{\partial \theta_2},…, \frac{\partial }{\partial \theta_p} ] $</li>
<li>已有：$ p (x | \mathbf{\theta}) = \prod_{k=1}^{n}p(x_k | \theta)) $</li>
<li>我们定义 $ l(\mathbf{\theta})$ 为最大似然函数,以及对应的梯度算子：<script type="math/tex; mode=display">
l(\mathbf{\theta}) = log(p(D |\mathbf{\theta})) = \sum_{k = 1}^{n}log(p(x_k | \mathbf{\theta}))</script><script type="math/tex; mode=display">
\bigtriangledown_\theta l(\mathbf{\theta}) =\bigtriangledown_\theta log(p(D |\mathbf{\theta})) = \sum_{k = 1}^{n}\bigtriangledown_\theta log(p(x_k | \mathbf{\theta}))</script></li>
<li>我们通过算子为0得到最大似然估计：<script type="math/tex; mode=display">
\bigtriangledown_\theta l(\mathbf{\theta}) = 0</script></li>
</ol>
<p>ML主要应用于单高斯和多高斯中。</p>
<h2 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h2><p>Expectation-Maximum Algorithm</p>
<p>EM算法一般用于在概率模型中找最大似然估计，主要针对含有潜在变量的，将不完全的数据补成完全的。</p>
<p>对于含有潜在变量的，如果我们还是按照求最大似然估计的方法来解决的话（分别求偏导），会出现“和的对数”这种难以解决的情况。对于这种情况，我们要用辅助函数来帮助解决。</p>
<p><img src="/images/old-resources//Screen%20Shot%202017-03-09%20at%207.21.41%20PM.png" alt=""></p>
<p>我们定义一个辅助函数 $ A(x,x^t)$ 与 f(x) 在 $x^t$ 处相等，且满足 $f(x) \geq A(x,x^t) $</p>
<p>我们只要将辅助函数的最大值设为新的 $\theta$ ，通过多次迭代逐渐逼近 f(x) 的最大值。</p>
<p>我们可以利用Jensen不等式来推导：</p>
<p>根据Jensen不等式，我们可以得到，如果f是凸函数，x是随机变量，则：</p>
<script type="math/tex; mode=display">
E\[f(x)\] \geq f(E\[x\])</script><p>如果是凹函数则反之</p>
<p>因此我们可以推导得出一个辅助函数：(将潜在变量引入其中，log函数是凹函数)</p>
<script type="math/tex; mode=display">
\begin{eqnarray}
\log{p(\mathbf{X} | \Theta)} & = & \log{\sum_y{p(\mathbf{x},y | \Theta)}} \\
& = & \log{q(y)\frac{\sum_y{p(\mathbf{x},y | \Theta)}}{q(y)}} \\
& \geq & \sum_y q(y) \log(\frac{p(\mathbf{x},y | \Theta)}{q(y)})
\end{eqnarray}</script><p>因此，EM算法具体可以分为以下四个步骤：</p>
<ol>
<li>对参数进行初始化设置，为 $\Theta^{old}$</li>
<li>E-step: 估计出 $p(y | x, \Theta^{old})$<script type="math/tex; mode=display">
Q(\Theta, \Theta^{old}) = \sum_y{p(y | x, \Theta^{old}) \log(p(\mathbf{x},y|\Theta))}</script></li>
<li>M-step: 用最大似然估计来估计$ \Theta^{new}$<script type="math/tex; mode=display">
\Theta^{new} = \arg \max_\Theta Q(\Theta, \Theta^{old})</script></li>
<li>检查是否收敛，如果不是$\Theta^{new} \rightarrow \Theta^{old}$ 并返回步骤2</li>
</ol>
<p>EM 模型主要用于高斯混合模型 GMM 中。</p>
<h2 id="GMM模型"><a href="#GMM模型" class="headerlink" title="GMM模型"></a>GMM模型</h2><p>在一个多高斯混合模型中，数据是从多个单高斯中生成出来的，即：</p>
<script type="math/tex; mode=display">
P(x) = \sum_{k=1}^{K} \pi_k N(x;u_k,\Sigma_k)</script><p>其中，$\pi_k$ 是权重值，总的和为1.</p>
<p>对于一个GMM模型，如果K的值足够大的话，混合模型就可以逼近任意的连续概率分布。</p>
<p>GMM模型本质上是一种聚类算法，每个高斯分布就是一个聚类中心。和K-means不同的在于，GMM是采用概率模型来表达聚类原型，因此可以给出一个样本属于某类的概率大小。</p>
<p>在每个样本的分类确定的情况下，GMM的参数可以直接用MLE的方法来确定。但是在只知道样本点而不知道其分类情况下，我们会得到一个这样的log-likehood的函数：</p>
<script type="math/tex; mode=display">
\sum_{i = 1}^N \log(\sum_{k = 1}^K \pi_k N(x;u_k,\Sigma_k))</script><p>在这个似然函数中，由于每个样本$x_i$所属的类别$z_k$是属于隐含变量的未知值，所以我们需要用EM算法来计算出模型的参数（使得上式的期望最大），然后可以用这些算好的参数来对样本进行分类。</p>
<p>E-step: 假设模型参数已知，求隐含变量分类Z的期望，即个个高斯分布的概率</p>
<p>M-step: 根据E-step中求得的分类，用MLE的方法求得参数。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>EM</tag>
        <tag>GMM</tag>
      </tags>
  </entry>
  <entry>
    <title>做一只孤独的美食家</title>
    <url>/2017/02/23/%E5%81%9A%E4%B8%80%E5%8F%AA%E5%AD%A4%E7%8B%AC%E7%9A%84%E7%BE%8E%E9%A3%9F%E5%AE%B6/</url>
    <content><![CDATA[<p>本篇随笔记录了一次意外的美食之行，在广州能尝到美味的怀石料理，简直是不能更满足。幸甚至哉，遂作此篇，见笑。<br><span id="more"></span></p>
<p>如果问我，生命中什么是重要的？两年前的我大概会回答说唯美食与美女不可弃，而现在的我的回答就要简练的多 —— 唯美食不可弃。看吧，不变的始终是那份对美食的热爱。</p>
<p>作为吃货的我有两部珍藏已久的电视剧，每当情绪低落或是想要静下心来的时候就会打开欣赏，感觉整个人一下子便获得了宁静，一种潜藏着的小喜悦变会逐渐地洋溢开来，暖却全身。这两部便是《深夜食堂》与《孤独的美食家》，一部是从家常的食物间找寻人生的真谛，一部是在平凡的生活中寻觅非凡的美味。美食即人生，两者间的交错互融才使得我们的生活更加丰富多彩。</p>
<p>由于要急着要简历照，我不得不在下午三点赶到珠江新城进行拍摄。在前一天预约的时候，我就心想这时间不尴不尬好生难受。拍完会学校吧，岂不枉费一次进城放荡的机会；拍完吃饭吧，又离着饭点有些遥远。</p>
<p>仔细这么一琢磨，我倒也觉得是该好好放松下身心了，所以就找起了周边的美食。一边找着，心里就浮现出了《孤独的美食家》中，五郎每每办完正事后在街头巷尾找寻美味的画面，以及那句在三个层层拉近的镜头后说出的“好饿啊！”。这么想着想着就怀念起了在日本吃过的那次怀石料理（脑洞好大。。。），恰逢enjoy上有一家店正搞着优惠，机不可失我便决定拍完照后前去享受一番。</p>
<p>说了这么多的废话，换做高中的语文阅读，这些便叫做引出主题。</p>
<p>写了这么多心理的执念和脑洞，此时再犹抱琵琶半遮面岂不扫兴？话不多说直接上图：</p>
<p>一进入餐厅落座，一封日文写的小纸条早已躺在桌台上，虽然看不太懂，但是心里总还是暖暖的。<br><img src="/images/old-resources/IMG_1378.JPG" alt=""></p>
<p>首先端上来的就是作为吸物的时令和风汤，是由南瓜等熬制而成，入口醇厚，香甜而不腻，微咸而素雅。在今日寒风凛冽的广州可真是驱寒开胃的佳品。<br><img src="/images/old-resources/IMG_1380.JPG?imageMogr2/rotate/90" alt=""></p>
<p>由于餐厅内客人较多，服务员和我商议后决定先将第四道菜品，烧物，端上来先行品尝。这次的烧物由银鳕鱼烹制而成，配上脆爽可口的秋葵，筋道美味的菌菇，以及银鳕鱼的油而不腻，饱满而又丰腴的鱼肉一次次融化在我的舌尖，日料的美味真是让人赞不绝口。<br><img src="/images/old-resources/IMG_1382.JPG?imageMogr2/rotate/90" alt=""></p>
<p>接下来的也是我最为喜欢的，就是八寸和刺身了。这盘菜端上来的时候，服务员还特地为我一一介绍，从品种到做法到吃饭，也让我见识了一番。分别有鲜甜嫩滑的蓝鳍金枪鱼刺身，肉质厚重味道鲜美的稠鱼刺身，还有甜虾、青鱼和海螺刺身。此外还有美味的和牛寿司、土豆沙拉球、玉子烧、春卷、腌制番茄以及入口爆裂回味无穷的三文鱼籽。好一番大快朵颐！<br><img src="/images/old-resources/IMG_1383.JPG?imageMogr2/rotate/90" alt=""></p>
<p><img src="/images/old-resources/IMG_1384.JPG?imageMogr2/rotate/90" alt=""></p>
<p><img src="/images/old-resources/IMG_1386.JPG" alt=""></p>
<p>接下来就是香甜的和牛肉炖土豆以及鲜美的汤了<br><img src="/images/old-resources/IMG_1387.JPG?imageMogr2/rotate/90" alt=""></p>
<p><img src="/images/old-resources/IMG_1385.JPG?imageMogr2/rotate/90" alt=""></p>
<p>而压轴的寿司也是让我不虚此行，尤其是蓝鳍金枪鱼寿司，简直好次到炸裂！鳗鱼寿司也是软糯美味到不行！<br><img src="/images/old-resources/IMG_1389.JPG" alt=""></p>
<p><img src="/images/old-resources/IMG_1391.JPG" alt=""></p>
<p>最后的抹茶布丁也是让我口留余香，抹茶的厚重与布丁的甜美交织在一起，升华了这次的用餐。</p>
<p><img src="/images/old-resources/IMG_1393.JPG?imageMogr2/rotate/90" alt=""></p>
<h2 id="如果可以，做一名孤独的美食家可好？"><a href="#如果可以，做一名孤独的美食家可好？" class="headerlink" title="如果可以，做一名孤独的美食家可好？"></a>如果可以，做一名孤独的美食家可好？</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>美食</tag>
        <tag>广州</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep Learning Chapter 1</title>
    <url>/2017/02/22/Deep-learning-Chapter-1/</url>
    <content><![CDATA[<p>最近想要系统地学习下deep learning，因此找了Ian Goodfellow写的”Deep Learning”一书来啃，我会将每章所讲内容整理后放在blog上。本篇就简要介绍下deep learning一书的第一章，Introduction。</p>
<span id="more"></span>
<h2 id="What-is-Deep-Learning？"><a href="#What-is-Deep-Learning？" class="headerlink" title="What is Deep Learning？"></a>What is Deep Learning？</h2><p>什么是深度学习？虽然这一词早已为大家所熟知，但是这一概念可能大部分人都不胜了解。其实一张简单的韦恩图就可以清晰简洁的表示：</p>
<p><img src="/images/old-resources/Screen%20Shot%202017-02-22%20at%208.46.15%20PM.png" alt=""></p>
<p>简单地说，深度学习是一种表示学习(representation learning)，也是一种机器学习，可用于许多AI方法。</p>
<p>那么深度学习又和之前的这些概念有什么区别呢？</p>
<p><img src="/images/old-resources/Screen%20Shot%202017-02-22%20at%208.52.32%20PM.png" alt=""></p>
<p>从这张图中我们可以看出，对于经典的机器学习方法，我们需要手动设计出特点进行导入来实现目的。而Representation Learning则是能够自己发掘特征，找到并导入来实现结果。</p>
<p>而对于深度学习而言，特征的找取是分多层多次实现的：先是通过原有的数据进行简单的特征提取，再根据提取的简单特征，进一步提取出更加抽象的特征来，这层递增，最终实现结果。</p>
<p>以图像识别的例子而言就是这样的：</p>
<ol>
<li>第一层可以是edge，通过图像中像素值的突变来实现edge这一特征的提取；</li>
<li>第二层可以是corners and contours，在edge的基础上，我们可以识别出轮廓和角的边的集合，将轮廓和角等提取出来；</li>
<li>第三次则是object parts，通过轮廓和角的集合，我们可以测定处特定对象的整个部分；</li>
</ol>
<p>有了上述这三个hidden layer，我们就可以最终判断出图像是哪种物体了。</p>
<h2 id="Brief-Introduction-about-the-History"><a href="#Brief-Introduction-about-the-History" class="headerlink" title="Brief Introduction about the History"></a>Brief Introduction about the History</h2><p>之前我上过Ng在coursera上的“Machine Learning”课，在课的后半部分简要地带过了一些关于神经网络的知识点。如今想来，二三年前深度学习还大部分时候还是以神经网络这一概念展现在我们面前的。</p>
<p>的确，深度学习作为一个早已提出的概念，经历过三次发展浪潮，直到最近才以 Deep Learning 这一词示人。</p>
<p>在Ng课中介绍的神经网络，就是一种从神经科学的角度出发的简单的线性模型。这些模型被设计为使用一组n个输入{x1,…,xn}，并将其与一个输出y关联，这些模型希望学习一组权重{w1,…,wn},输出y=x1 <em> w1 + … + xn </em> wn，多层这样的结果就构成了这种早期的神经网络的雏形。一般是用back-propagation的方法来进行参数的训练。这种方法直至今日仍然是训练深度模型的主导方法。</p>
<p>由于多层的结构再加上多层之间的信息传递（训练时的正向、反向传播），使得这一模型也被称为神经网络模型。的确神经科学被视为深度学习研究的一个重要灵感来源，但是由于我们没有足够的关于大脑的信息来进行进一步研究指导，其作用逐渐被削弱。现在的大多数神经网络是基于一个成为Rectified linear unit的神经单元模型。</p>
<p>在80年代，神经网络在认知科学的背景下随着Connectionism或者说parallel distributed processing的出现而引来了又一个发展高潮。通过将大量简单的计算单元连接在一起构成网络从而实现智能的行为，用分布式表示的方法，将多个特征彼此分立开，每个输入都有多个特征表示，每个特征都参与表示多个输入，从而分立进行训练。随着back-propagation的普及，这种方法走向了潮流。</p>
<p>随着硬件的发展，当年遥不可及的计算代价如今得以了实现，从而引来了第三次的发展。而大量的数据集的出现也使得训练变得更为方便和准确，而模型规模的增大也使得能够实现更多复杂的内容。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>读数笔记</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>Zero padding</title>
    <url>/2017/02/21/Zero-padding/</url>
    <content><![CDATA[<p>本文详细介绍在信号处理过程中的zero padding的作用和意义。<br><span id="more"></span></p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="CTFT"><a href="#CTFT" class="headerlink" title="CTFT"></a>CTFT</h3><p>连续时间傅里叶变换(Continuous time Fourier Transform),公式在此不做赘述，表示的是连续无限长的时间域函数通过傅里叶变换转换到连续无限长的频域函数。<br>CTFT的概念存在于物理世界中，在真正现实中处理信号时是无法得到连续信号的，必然是离散的</p>
<h3 id="DTFT"><a href="#DTFT" class="headerlink" title="DTFT"></a>DTFT</h3><p>离散时间傅里叶变换(Discrete time Fourier Transform)，表示的是离散无限长的时间域函数通过傅里叶变换转换到连续无限长的频域函数。<br>同样的DTFT的概念存在于信号处理的理论中，在真实处理信号时是无法得到无限长的离散采样点，必然是有限长的离散采样点。</p>
<h3 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h3><p>离散傅里叶变换(Discrete Fourier Transform)，表示的是有限长的离散时间域函数通过傅里叶变换转换到离散有限长的频域函数。<br>这是我们在信号处理时采用的方法。需要注意的是，在运用DFT的时候还要注意香农定理，避免出现混叠</p>
<h2 id="DFT存在的问题"><a href="#DFT存在的问题" class="headerlink" title="DFT存在的问题"></a>DFT存在的问题</h2><p>在实际处理信号的过程中，我们发现：由于时域采样点的个数有限，频域上的频率反映会和实际的有一定差别，如下图所示</p>
<p>无限长的时域函数的傅里叶变换结果：<br><img src="/images/old-resources/Picture1.png" alt=""> </p>
<p>有限长的时域函数的傅里叶变换结果<br><img src="/images/old-resources/Picture2.png" alt=""></p>
<p>我们发现不仅会出现side lope，还会出现△f。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>最简单的解决方法就是增加采样点的个数，然后在实际中由于硬件等一系列的原因，我们无法实现增加采样点，这时就可以用zero padding的方法来进行补救。</p>
<h3 id="zero-padding"><a href="#zero-padding" class="headerlink" title="zero padding"></a>zero padding</h3><p>zero padding本质上是通过在不影响结果的情况下，通过增加采样点的个数来实现对插值结果的预测，从而更好地表示变换后的细节。</p>
<h4 id="时域上的-zero-padding"><a href="#时域上的-zero-padding" class="headerlink" title="时域上的 zero padding"></a>时域上的 zero padding</h4><p>时域上的zero padding主要是在采样点后增加一定长度的值为0的点。<br><img src="/images/old-resources/1.png" alt=""> </p>
<p>增加后的结果中，我们可以很明显的看到，△f明显有了减小。<br><img src="/images/old-resources/2.png" alt=""></p>
<p><img src="/images/old-resources/3.png" alt=""></p>
<h4 id="频域上的-zero-padding"><a href="#频域上的-zero-padding" class="headerlink" title="频域上的 zero padding"></a>频域上的 zero padding</h4><p>对于频域而言，zero padding之前我们要先了解频域的分布，对于一个频域函数而言，一半的位置是正负值的分水岭，而其表示直流分量的零点则表示在一头一尾处，所以我们在进行zero padding的过程中，就要先将频域函数对半切开，在中间增加为0的点。只有这样才会在不影响原有的频域的分布基础上，增加频域的范围。</p>
<p>我们知道，对于DFT和IDFT而言，频域点的个数和时域点的个数是相同的，所以我们在这样做之后，就相当于拓展了时域的点的个数，在原有两点中间加上了插值点，表现出了细节。</p>
<h2 id="zero-padding的意义"><a href="#zero-padding的意义" class="headerlink" title="zero padding的意义"></a>zero padding的意义</h2><h3 id="不改变数据"><a href="#不改变数据" class="headerlink" title="不改变数据"></a>不改变数据</h3><p>无论是频域和时域上的zero padding，都不会改变数据本身，仅仅只是改变了数据样本点的密度。</p>
<h3 id="更好地体现细节"><a href="#更好地体现细节" class="headerlink" title="更好地体现细节"></a>更好地体现细节</h3><p>无论是频域和时域上的zero padding，都增加了数据样本点的密度，等价于在对应的另一个域上进行了插值。而这个插值我们原本是无从计算的，正是通过zero padding才实现了对插值的估计。</p>
<h3 id="便于应用FFT算法"><a href="#便于应用FFT算法" class="headerlink" title="便于应用FFT算法"></a>便于应用FFT算法</h3><p>我们知道，快速傅里叶变换FFT算法需要 2 的 n 次方的样本点，而通过zero padding可以将样本点的个数凑成 2 的 n 次方，便于实现算法上的优化。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>信号处理</category>
      </categories>
      <tags>
        <tag>傅里叶变换</tag>
        <tag>DFT</tag>
        <tag>IDFT</tag>
      </tags>
  </entry>
  <entry>
    <title>我看日剧</title>
    <url>/2017/02/08/%E6%88%91%E7%9C%8B%E6%97%A5%E5%89%A7/</url>
    <content><![CDATA[<p>关于夏天的记忆，是浴衣，花火，以及长泽雅美。<br>而关于日剧的记忆，我想，除了帅哥美女，就是对人性的入木三分，以及，对生活的不离不弃。</p>
<span id="more"></span>
<p>大概是被《逃避虽可耻但有用》中可爱的gakki所吸引，整个寒假我都沉浸在日剧的汪洋中，从最开始“单纯”欣赏各色女主的颜，到一步步被日剧的精彩攥着一刻不想脱身。</p>
<p>我猜想，大部分热爱日剧的人，应该和我一样，都是通过新垣结衣、长泽雅美、山下智久或是山田孝之等盛世美颜第一次与日剧结缘。不同于某半岛国千篇一律的妖艳美丽，风流倜傥，岛国演员们给人最深的印象就是各具风骚，可以是gakki治愈人心的回眸一笑，可以是长泽大妈令人痴迷的美腿，可以是户田惠梨香调皮的兔牙······不过，自古美人如名将，不教人间见白头，仅凭颜值的话，注定是无法长久的。那么又是什么给我们以长久的追剧动力呢？</p>
<p>作为一个比较理性的观众，近年来的国产剧和韩剧令我望而却步的主要原因，一是对爱情的过分追求，达到无处不在的程度。不论是刑侦还是医疗剧，主线一定是主角的爱情生活，为爱痴狂，为爱奉献，为爱牺牲。的确我不能否认，爱情是人生中重要的一环，但是生活并不仅仅只有爱情，这种将其剥离然后高高贡起的做法着实令我厌恶。</p>
<p>而另一主因，就是剧的深度问题。对比日剧，国产剧和韩剧更像是流水化工厂的结晶，一模一样的套路配上似曾相识的表演，完成对爱情的讴歌和才子配佳人的美好结局。作为一部青春剧，《求婚大作战》就能让我感慨“花有重开时，人无再少年”，人生需要抓住每一个当下，这样才能在回首往昔时不留遗憾，无需一次次的“哈利路亚chance”。作为一部医疗剧，《code blue》能让我在了解直升机救援的同时深入医护人员的内心，体验日式的医患关系，治人需治心。作为脑洞剧的开山怪，《父女七日变》带我们走进了青春期父女的内心世界，感触温润亲情的同时也为编剧的想象力所折服。更别提《legal high》《半泽直树》这类直击社会的写实之作，更是用坚如磐石的三观圈住了大片的饭。</p>
<p>从这一部部十集左右的剧中，我们所看到的不单单是丰富的情感，精彩的表演，跌宕的情节，更有着对人性的挖掘和讨论，对生活的感触和憧憬，我想这或许就是日剧在剥离一位位盛世美颜后仍能深攥人心的原因吧。</p>
<p>或许，在未来的某一天，我也会抛弃日剧，但是，日剧曾带给我的那份感动，那份对生活的憧憬，将在我内心留下烙印，永久不褪。</p>
<p><em>【写在最后】有人说看韩剧找不到男朋友，看日剧找不到女朋友。我希望这不是真的。。。</em></p>
<p><img src="/images/old-resources/p2398165751.jpg" alt=""></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title>巨人的陨落</title>
    <url>/2017/01/18/%E3%80%8A%E5%B7%A8%E4%BA%BA%E7%9A%84%E9%99%A8%E8%90%BD%E3%80%8B/</url>
    <content><![CDATA[<p>都说历史是一个任人打扮的小姑娘，可架不住看客犀利的目光。从没有一段“淡妆浓抹总相宜”，浓妆艳抹和略施粉黛间的取舍全仗笔者的底蕴。</p>
<p>抽空拜读了肯·福莱特世纪三部曲之一的《巨人的陨落》，深有感触。其通过POV方式的以小见大，带我领略了一战前后的英德法俄美。从大国外交到战争，从权贵达官到平民百姓，书中从一位位主人公的视角出发，勾勒出了一段段充满感情的鲜活历史。</p>
<span id="more"></span>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>全书以4个国家中的5个家族为线索（俄国的别斯科夫、英国的菲兹赫伯特和威廉姆斯、德国的冯·乌尔里希、美国的杜瓦），通过第一人称POV手法，详细介绍了各自国家在一战前后的各种状况。</p>
<p>作者巧妙地将这5个家族定位在不同的阶级上，既有传统贵族的菲兹赫伯特与冯乌尔里希家族，也有新兴的杜瓦家族，同时还有工人阶级的威廉姆斯家族以及代表着传统俄国农民在变革时代间变迁的别斯科夫家族。</p>
<p>正是这巧妙的定位，使得我们得以如亲历般见证着：</p>
<ul>
<li>一战爆发前英德法俄奥之间的外交对话。个人对这段格外着迷，以一个个国家精英的视角生动展现了国家政治外交上的隐忍与取舍。</li>
<li>一战中贵族的军官视角，平民的战士视角。正是一战加速了欧洲大陆传统贵族的没落。</li>
<li>俄国二月革命、十月革命的萌芽与诞生（列宁的归来）</li>
<li>战后协约国间形如分赃般的丑恶嘴脸，以及战后德国的糟糕境地。</li>
</ul>
<p>本书以 <em>Fall of Giants</em> 为名，以一 <strong>fall</strong> 表示了欧洲大陆经过一战后的由盛转衰，同时还意味着战后的欧洲传统贵族开始走向了没落，战时战后尤以英国为主的妇女平权运动打破了以往男盛女衰的格局。</p>
<p>最令我感到惊讶的是作者写在文后的那句话</p>
<blockquote>
<p>我的原则是：要么某一场景真实发生过，或者有可能发生；要么某些话真正说过，或者有可能说。如果我发现有某种原因让某种场景不可能真正发生，或不可能说出某些话——例如某个人物当时处于另一个国家，我便将其略去。</p>
</blockquote>
<p>我想，这或许就是读完全文如此舒畅的原因了吧。</p>
<h2 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h2><p>如果说要让我从整本书中选出最有感触的一段，我想就要数关于俄国革命的部分了。</p>
<p>书中一段格雷戈里的内心活动一下子就抓住了我的心</p>
<blockquote>
<p>一个孩子的成长就像一场革命，格雷戈里心想，你可以让他诞生，但后来如何就全然不在你的掌控之下了。</p>
</blockquote>
<p>不像我国媒体般吹嘘十月（二月）革命的伟大，也不同西方媒体般对苏维埃敬而远之，书中以及其克制的手法，分别从俄国国内贵族和平民，以及英国贵族与平民的角度，多方面阐述了对革命的看法。</p>
<p>有沙皇治下的市民吃不上面包，有警察枪击手无寸铁的游行群众，也有革命之时大街上的打砸抢烧；有贵族不经审判绞死“侵占”自家空闲领地的农民，有军官贪污军需置士兵的死活与不顾，也有革命成功后苏维埃政权向贫穷农户强征口粮甚至枪毙不配合者。</p>
<p>的确，革命势在必行，但是在打破旧制度制定新制度的过程中，又有谁能确保自己不会成为那些打败恶龙最终成为恶龙的勇士呢？苏维埃是少数敢于站出来挑战沙皇权威的政党，以反对对人民的压迫，还人民以土地作为党的纲领，但是执政后也强抢粮食并枪毙不肯交粮的农民，甚至枪毙倒向孟什维克党的工人。</p>
<p>或许恶龙和勇士就是一条莫比乌斯带，我们永远不知道究竟是那一面。</p>
<p><em>写在文后：上述感想只是单纯讨论苏维埃政权，请勿发散思维！！</em></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>Head First Civilization V</title>
    <url>/2017/01/09/Civilization-V/</url>
    <content><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>让我们将地球的时钟拨到远古世纪，蜿蜒的河流边正孕育着文明的曙光，一队队移民正取下行装，准备在历史的长河中书写壮丽的篇章。一座座简陋的城市如雨后春笋般拔地而起，勾勒着美好的希望。手持木棒的勇士正开疆拓土，怀揣着一统天下的梦想。</p>
<p>上述这些画面描述的就是文明系列游戏的开场。一把文明游戏就仿佛是人类文明盛衰兴亡的缩影，带给我的感触绝非是一般游戏可比拟的。一句话，文明系列，不仅仅是游戏。</p>
<span id="more"></span>
<p>如果说有什么游戏值得我整整一天宅在电脑前废寝忘食，那一定是席大大的文明系列。而在6代bug不断，4代画质感人的今日，5代的美丽新世界显得格外诱人，在一个又一个“next turn”的指引下，一切都如白驹过隙，一晃而逝。（友情提示，没有闹钟的，没有自制力的，请远离文明系列）</p>
<h2 id="宏观看文明"><a href="#宏观看文明" class="headerlink" title="宏观看文明"></a>宏观看文明</h2><p>虽然不像P社四萌那样有着极高的历史还原度，但是在宏观层面上对人类文明的量化和物化我从未见过如文明这般卓越的。它将人类文明的核心量化为科技和文化，而各个国家的实力物化为一个个城市以及单位，彼此之间相互影响，构成了整个复杂交错的文明世界，也让玩家看到了数千年来人类文明发展的缩影，闲暇之余颇有感触。</p>
<h3 id="科技与文化"><a href="#科技与文化" class="headerlink" title="科技与文化"></a>科技与文化</h3><p>在Civilization这系列游戏中，人类文明时刻被文化和科技点数推进着前行。随着科技的飞速发展，科技树茁壮成长着，一个个闻所未闻的建筑和单位出现在了城市的建设列表中，等待着一国之主的召唤。它们将进一步促进科技和文化的发展。而随着文化的积累，一项项政策被从上锁的黑箱拿上了台面，如同现在的城市规划和国家方针一样，指引着帝国步入黄金时代，迈入胜利的殿堂。</p>
<p>的确，人类的文明从来都是一个厚积而薄发的过程，没有前期挖石头的技术，哪来之后的石油、煤矿等的大发现？没有律法的出现，哪来的意识形态的选择？纵使给远古时代的人民一百个爱因斯坦，也注定不会有相对论和量子力学的丁点萌芽。这也是为什么，在游戏中，政策的选择局限于时代，科技的研发取决于之前的积累。</p>
<h3 id="城市与单位"><a href="#城市与单位" class="headerlink" title="城市与单位"></a>城市与单位</h3><p>玩家通过建造城市设施和调整市民工作来实现一个城市在粮食、产能、金钱、文化和信仰等方面的平衡，使之为帝国的发展贡献力量。每每在进入城市界面时，我的脑海中浮现的不是一个个单调的数字或是乏味的图标，而是一个个活生生的市民为了生计在城市之郊辛勤工作，为城市的产能和产粮做出微不足道的贡献。这样的生化当然难言快乐，尤其是当城市人口急剧膨胀之际，辛勤劳作了一天的市民不得不蜷曲在狭小的住处休息，这也是为什么在游戏中人口和城市数量的增长会带来大幅的不快乐。于国家而言，哪里有城市，哪里就有剥削，除非危及自身统治，人民的快乐不足为道，这又何尝不是现实生活的一个缩影呢？通过产出奢侈品和建设娱乐设施，市民们的快乐可以得到大幅提升，似乎被剥削的不快早已被抛之脑后，看来娱乐至死的年代由来已久啊。</p>
<p>如果说用一句话总结文明系列的精髓，那就是国家的利益高于一切。在游戏界面中，渺渺众生不过是一串串简单的数字，一队队忠义无双的士兵，一个个任劳任怨的劳工。他们在玩家的带领下，为着最终的胜利默默奉献着自己。游戏中，为了保住珍贵的笑脸，我们往往不惜将攻占的城市付之一炬，看着城市的人口一回合一回合地下降，直至城池变为废墟。为了省下足够的金钱，我们往往会将多余的单位就地处决，看着他们化作一道光永远消逝在历史的长河中。为了抢在AI之前造出奇观，我们往往会强制让市民忍饥挨饿，没日没夜地为产能贡献力量。沉浸在游戏中的我们又怎会意识到呢，这些不就是曾经的“嘉定三屠”，“扬州十日”，“长平之战”后的白起杀降，布尔什维克在战后依然实施的“战时共产主义”？</p>
<p>唯一带点个人色彩的也就是在城市中产出的伟人了，他们有着与真实历史中某位名人相同的名字，而在游戏中他们的命运也不外乎是为了一项奇观、一项科技、一个作品或是一场战役，鞠躬尽瘁死而后已。可即便如此，他们还是一个个义无反顾地诞生于城市，为了帝国的繁荣昌盛前赴后继。真可谓是“苟利国家生死以，岂因祸福避趋之”。</p>
<h3 id="国家和城邦"><a href="#国家和城邦" class="headerlink" title="国家和城邦"></a>国家和城邦</h3><p>文明系列游戏经久不息的一个原因，就在于多样的文明种类。玩家可以从二三十个文明中挑选一个进行游戏，而这二三十个文明也都各具特色。好玩的一点在于，游戏选取这些文明中的一位著名统治者，将其作为游戏中该文明的领袖。所以在游戏界面中，我们得以看这样的场景，骑在马上的拿破仑不屑地评论着我羸弱的士兵，白宫中的华盛顿义正言辞地进行抗议，雍容华贵的武则天不怒自威地否决了我的交易。正是这些文明领袖们将我们更好地带入了游戏中，将复杂难表的国家关系用领袖们的喜怒哀乐鲜活地呈现给了玩家。</p>
<p>在文明游戏中，国家关系是一个很重要的部分。两国间的良好关系是进行合作研究以及现金交易的前提。同时两国间的贸易也必须在非战争状态的条件下才能进行。这不就是现实的一个缩影吗？</p>
<p>除了国家之外，在游戏中玩家还会碰到许多城邦，也就是现实中的“小国”。在第一次遇到时它们会给你一些钱，我总是开玩笑地说这是供奉给大国的礼金，摆出低调的姿态祈求乱世中的苟存。刚玩的时候我总是对这些城邦不屑一顾，对这些蝼蚁一直提出的烦人任务不理不睬。看着它们一个个成为了其他国家的盟友，想着这些小国送给你们也没什么用处，就这样一直开开心心地在家种田。一转眼国际形势骤变，昔日笑脸相迎的对手最终兵戎详见，我惊讶地发现那些城邦也都紧跟着它们主子的步伐，争先恐后地对我宣战。我当时第一个想到的不是打开存档，而是“这不就是北约？”。玩得越多，我越觉得城邦好处大大的，盟友会给你兵，给你文化，给你粮食，给你资源，给你信仰，还能给你快乐！而如果觉得完成城邦任务太麻烦，大可以拿钱砸，一堆堆金子砸在城邦的脸上，玩家就能享受到如同城邦爸爸一般的待遇，给吃给喝还能帮打架。</p>
<p>可以说文明中对国家和城邦的设定很好地诠释出了大国与小国间的外交政策与外交姿态。</p>
<h3 id="胜利种类"><a href="#胜利种类" class="headerlink" title="胜利种类"></a>胜利种类</h3><p>在Civilization V这款游戏中，总共有5种胜利的方式，而这5种方式也给玩家以不同的感悟。</p>
<h4 id="外交胜利"><a href="#外交胜利" class="headerlink" title="外交胜利"></a>外交胜利</h4><p>有人说，联合国建立的意义是为了让全世界更好地按照大国意志来运转，而事实也确有几分相似。诸如伊拉克战争、古巴禁运等事件就是大国通过对联合国的控制来实现对小国的支配，从而更好地实现自身利益。在文明游戏中也是亦然，一旦世界议会选出了世界领袖，那么也就意味着该国有着将自己的意志以世界议会中某一议题的形式强加于他国的能力，也就实现了外交上的胜利。</p>
<h4 id="征服胜利"><a href="#征服胜利" class="headerlink" title="征服胜利"></a>征服胜利</h4><p>文明V这款游戏也被称为野蛮V，不打仗怎么赢天下。一个无论科技和文化都远远落后的文明要想赢得游戏，只有用武力打破现有的状态。一旦取得了所有文明的首都，就取得了征服胜利。</p>
<p>作为一名爱好和平的种田流玩家，从个人理念出发我是十分不喜欢玩征服胜利的，一个原因自然是因为操纵“百万大军”攻城下寨是一件极其繁琐的事。还有一个很重要的原因是我在游戏过程中探索出来的：在飞船起飞前的一回合，我抱着玩一玩的心态将我的“小男孩一号”原子弹投向了身边的埃及，瞬间一座人口30+的主城血条只剩下了一半左右，周边的单位也是死伤惨重，城市中隐约还有人群大喊哭泣的声音，虽然知道这不过是游戏一场，但是内心总感觉有些堵。当然啦，打仗是一定要打的，不过我更喜欢逼得对面割地赔款，然后我在安安心心发战争财。</p>
<h4 id="科技胜利"><a href="#科技胜利" class="headerlink" title="科技胜利"></a>科技胜利</h4><p>从仰望星空开始的不仅仅有哲学，还有科学！将人类文明传播到更为浩瀚的宇宙一直是科学家们的梦想，也支撑着他们燃烧自己，成就科学的跃进。当飞船起飞的一刹那，人类文明的种子已播撒在银河系中，承载着无数人的梦想驶向远方。这也是我最喜欢的胜利模式！</p>
<h4 id="文化胜利"><a href="#文化胜利" class="headerlink" title="文化胜利"></a>文化胜利</h4><p>当玩家的文化支配了其他文明，当那里的人民都穿着我们的衣服，说着我们的语言的时候，我们还能说这是别的国家吗？文化胜利的本质就是通过本国文化对他国潜移默化的影响，通过人民的融合实现国家的兼并。实现难度着实不小（一般都是打出来的。。。）</p>
<h4 id="时间胜利"><a href="#时间胜利" class="headerlink" title="时间胜利"></a>时间胜利</h4><p>（一般都关闭时间胜利）满满都是吐槽。。。在世界末日前的那一刻，上帝说，拯救那个分数最高的文明吧，于是就有了时间胜利。。。（2050年分数最高的玩家获胜）</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>开了程序猿的脑洞写下了这篇civilization的Head First，文明带给我的不仅仅是绝佳的游戏体验，还让我有了很多思考，打算有时间出一篇Thinking in Civilization。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Games</tag>
        <tag>Civilization</tag>
      </tags>
  </entry>
  <entry>
    <title>Concurrent Programming</title>
    <url>/2016/12/10/concurrent-programming/</url>
    <content><![CDATA[<p>并发在应用程序中起着很重要的作用，本文将详细介绍应用级的并发</p>
<span id="more"></span>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是构造并发程序最为简单的方法。在CSAPP的第八章中就已经介绍过：进程本质上就是一个执行中的程序的实例，每当我们运行一个程序的时候就会创建一个进程并在其上运行相关文件。<br><br>而进程在真正运行的过程中并不是独占处理器的，根据不同的逻辑控制流（每个进程的PC值），不同的进程轮流使用处理器。如果不同的进程在运行过程中有时间的重叠，则两者之间是并发的关系。<br><br>采用进程的并发方式可以在父子进程之间共享文件，同时两者不同的地址可以避免彼此信息的覆盖问题。但是这种方式不得不采用IPC（进程间通信）的方式来交换彼此的信息，而这是一种开销很大的方式，大大降低运行的速度。<br></p>
<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>当我们在浏览一个网页的时候，服务器可以同时处理浏览器发送的请求和用户输入的指令，而这主要采用的就是I/O多路复用的方法。<br><br>其核心思想就是采用select函数，要求内核挂起进程，仅当一个或多个I/O事件发生后才将其返回给应用程序。本质上这种方法下我们创建自己的逻辑流，利用I/O多路复用来进行流的调度。<br><br>这种方法的一个最大的优点就是信息交换的便捷，共享数据来得更为高效<em>(无需在流之间切换)</em>，使我们对程序有着更好的掌控<br><br>但是与此同时，与第一种方法相比，编码量的复杂度大大提升。而且一旦某一逻辑流在读某一文本，其他流就不能读了。这也是不是很高效的一点。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>与进程是运行在系统中的逻辑流对应的，线程是运行在进程中的逻辑流，每个线程都有着唯一的整数ID、栈指针、栈、计数器、寄存器等等，运行在一个进程中的线程共享该进程的整个虚拟地址空间。从本质上讲，这种方法更像是上述两种方法的结合。<br></p>
<h3 id="线程是如何执行的"><a href="#线程是如何执行的" class="headerlink" title="线程是如何执行的"></a>线程是如何执行的</h3><p>所有的进程在最开始的时候都是单线程的，这个线程就是主线程。随后在某一时间点主线程会创建一个对等线程并与之一起并发运行<em>（来回切换）</em><br><img src="/images/old-resources/Screen%20Shot%202016-12-10%20at%203.50.33%20PM.png" alt="线程示意图"><br>由于线程的context对比进程而言要小得多，所以线程之间的切换也要快得多。主线程和对等线程之间基本上是相同的，都能读写相同的共享信息。<br></p>
<h3 id="线程相关函数"><a href="#线程相关函数" class="headerlink" title="线程相关函数"></a>线程相关函数</h3><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span><span class="keyword">typedef</span> <span class="type">void</span> *(func)(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns 0 if OK, nonzero on error</span><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">pthread_attr_t</span> *attr, func *f, <span class="type">void</span> *arg)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns thread ID of caller</span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="结束线程"><a href="#结束线程" class="headerlink" title="结束线程"></a>结束线程</h4><p>当调用下述函数时，主线程会等待所有对等线程终止时在终止自己和整个进程。否则则当线程运行完后隐式终止。<br></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// terminate threads</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *thread_return)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h4><p>在线程被创建后，其默认是可结合的，即可以被其他线程回收杀死，而下面的函数则可以将其分离，仅当其终止时才自动释放存储。<br></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// detach threads</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;   <span class="comment">// Returns 0 if OK, nonzero on error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="线程中同步变量"><a href="#线程中同步变量" class="headerlink" title="线程中同步变量"></a>线程中同步变量</h3><p>各个线程彼此之间可以共享变量和文件，但是如果不加限制有时会造成同步错误。<br><br>因此，在文件或是变量同步(读写)的过程中，并发的程序有着种种的限制。在本书讲pipeline的过程中就介绍过read after write的问题。在pipeline中如果先写后读则读的过程至少需要等待三个周期才能保证不出错<em>（当然在forwarding的方法下我们可以将等待周期减为1个）</em>。<br><br>同样的，我们在并发线程中进行文件或是变量读写操作的时候，也会遇到类似的问题：如果在某一线程读取某一变量值的同时，另一线程正在对改写这一变量<strong>(这里的同时指的并不是完全意义上的同时，而是很短的时间)</strong>，由于读和写都要一定时间，这就可能会造成数据的错误。因此我们需要对线程间的变量同步加以限制。主要采用Posix中的 P 和 V 操作。<br></p>
<ul>
<li>P(s)：加锁操作。若s非零则将其减1返回，否则挂起线程直至s非零。</li>
<li>V(s)：解锁操作。若有线程被P操作挂起则将s加1，重启该线程。</li>
</ul>
<p>因此，我们可以通过 P 和 V 操作实现线程中的变量同步。<br><br>以下代码展示了读者优先的线程，只要有一个读者在读，其他的读者就能忽略锁而毫无障碍的读取变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global variables</span></span><br><span class="line"><span class="type">int</span> readcnt;</span><br><span class="line"><span class="type">sem_t</span> mutex, w;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">  readcnt++;</span><br><span class="line">  <span class="keyword">if</span> (readcnt == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   P(&amp;w);</span><br><span class="line">  &#125;</span><br><span class="line">  V(&amp;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do the reading</span></span><br><span class="line"></span><br><span class="line">  P(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">         V(&amp;w);</span><br><span class="line">        &#125;</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程中的竞争问题"><a href="#线程中的竞争问题" class="headerlink" title="线程中的竞争问题"></a>线程中的竞争问题</h3><p>如果我们在构建线程时，每次创建一个新的对等线程都是通过传递一个指向唯一整数ID的指针的话，很有可能会导致程序的错误，因为在这种情况下各个线程会产生竞争。<br><br>而解决这种问题的方法也很简单，只需要用一个malloc函数为每个线程动态分配一个整数ID的指针，并将这个这个指针传递给构建线程的函数中。同时最后别忘了对指针进行free来避免memory leak。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Knowledge</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>proxy-lab</title>
    <url>/2016/12/09/proxy-lab/</url>
    <content><![CDATA[<p>Proxy Lab 作为 cmu 18600 以及 15213 这两门课的最后一个lab，其综合性非常强。既需要掌握好 web programming 以及 concurrent programming 的相关知识，还需要结合之前涉及的 shell 和 cache 的相关操作。<br><br>本文将详细介绍 proxy lab 的解题思路。</p>
<span id="more"></span>
<h2 id="什么是proxy"><a href="#什么是proxy" class="headerlink" title="什么是proxy"></a>什么是proxy</h2><p>首先，我们需要知道什么是<strong>proxy</strong>？<br><br>当我们平时打开浏览器的时候，输入一个URL，浏览器会向服务器发送相应的请求，服务器在接收到请求后会将相应的response发回给浏览器，如此循环往复从而加载完网页中的全部内容。<br><br>此时所有的请求和响应之间的交流全是发生在 client (浏览器)和 server (服务器)之间的。而有时我们会在client和server之间添加代理，来进行相关的处理，这个代理就是实验要求我们完成的proxy。<br></p>
<p><em>proxy的大致示意图如下所示</em></p>
<p><img src="/images/old-resources/Screen Shot 2016-12-09 at 10.35.56 PM.png" alt="流程图"><br></p>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>在本次实验中，我们采用的浏览器是Firefox，设置代理的过程如下所示：<br><br><em>打开设置中的高级，选择网络，点设置并按照如下设置（若proxy在本地则选择localhost或是127.0.0.1）</em><br><em>需要注意的是，端口一定要和之后运行proxy时的端口一致</em><br><img src="/images/old-resources/Screen Shot 2016-12-09 at 9.15.20 PM.png" alt="代理设置1"><br><br><img src="/images/old-resources/Screen Shot 2016-12-09 at 9.15.37 PM.png" alt="代理设置2"><br></p>
<h2 id="proxy如何处理request"><a href="#proxy如何处理request" class="headerlink" title="proxy如何处理request"></a>proxy如何处理request</h2><p>打开Firefox网页，Mac下alt + cmd + q，Win下按F12进行观察，点击每条可以显示出请求和响应的内容<br><img src="/images/old-resources/Screen Shot 2016-12-09 at 9.10.05 PM.png" alt="网页1"><br></p>
<p><img src="/images/old-resources/Screen Shot 2016-12-09 at 9.31.06 PM.png" alt="网页2"><br></p>
<p>通过这种方法，我们可以很轻松地看到请求和响应头。</p>
<p>而作为一个proxy，所需要做的事情主要有这么几件：<br></p>
<ol>
<li>从请求中获取请求的方法，请求网址的hostname，path以及port（没有的话为80）<em>(有多种方法解析，我采用的是正则表达式)</em> <br>  需要注意的是，本实验中不支持非get的方法，同时也不支持任何以HTTPS开头的网页请求。本实验中以501错误返回这类请求。<br> </li>
<li>改变请求头中的一些内容（比如User-Agent，connection改为close）<br></li>
<li>添加 Proxy-Connection: close，来确定请求响应的交换是否结束</li>
<li>改变原先请求中的version。<em>（从 HTTP/1.1 到HTTP/1.0）</em> <br></li>
</ol>
<p>对网页端发送请求进行修改之后，发送给服务器，再将response返回给网页端，如此循环往复直到网页内容加载完毕</p>
<h2 id="处理多线程操作"><a href="#处理多线程操作" class="headerlink" title="处理多线程操作"></a>处理多线程操作</h2><p>在完成上述内容之后，我们就实现了一个逐条处理网页端请求的proxy。但是在现实中这样的效率极其低下。所以对于我们的proxy还需要使其支持多线程操作。<br><br>其所涉及的函数如下所示<br></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>其中pthread_create函数用于打开一个新的线程，通过调用start_routine这个函数，而其中的arg是start_routine函数的参数。<br><br>特别要注意的是，arg一定要事先进行malloc，为每个线程ID分配一个独立的块，并将指向这个块的指针传给start_routine。不然线程会出现竞争问题导致错误。同时在结束线程时一定要释放这些块来避免memory leak<em>（我就是在这里跪了很久的。。。）</em></p>
<p>而第二个函数是用于在线程中防止线程被其他线程回收或杀死。</p>
<p>在第一步中加入上述函数，基本上就能够实现proxy的多线程操作的部分。</p>
<h2 id="存储网页内容"><a href="#存储网页内容" class="headerlink" title="存储网页内容"></a>存储网页内容</h2><p>以上的proxy已经基本完成了代理的要求。不过当我们重复请求某一个网址的时候，它还是要重新加载一遍，这就有点低效了。如果我们能够把之前网页端获取的响应存下来呢？这样当我们重复加载的时候就无需连接到服务器了。<br><br>所以，我们还要让我们的proxy能够存储网页的内容。<br>在本次实验中，我用一个类似于队列的双向链表来表示存储的cache。proxy在每次处理完网页端发来的请求后，先遍历整个链表，看是否有相同的request存在cache中，如果有就直接获取对应的response。没有的话就现将请求发动到server，将server返回的response写入到cache中。<br><br>在具体的操作中，我采用的是FIFO，每次都将新的request/response加在链表的头。一旦cache存储已满，就从尾部pop。<br><br>需要注意的是，一旦找到匹配的request之后，我们还需要将对应的node移到链表的头指针处。这样才符合FIFO。<br></p>
<p>上述就是我对与proxy lab的总结，希望大家都能做出一个完美的proxy！！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Knowledge</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>去雾算法浅析</title>
    <url>/2016/11/29/%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>何凯明博士在09年以 <a href="http://www.jiansun.org/papers/Dehaze_CVPR2009.pdf">“Single Image Haze Removal Using Dark Channel Prior”</a> 一文技惊四座。此文甚至成为09年的CVPR最佳论文。本篇博文将对这种去雾算法进行简要的分析，并通过自己的实现来更好的进行介绍。</p>
<span id="more"></span>
<h2 id="算法核心介绍"><a href="#算法核心介绍" class="headerlink" title="算法核心介绍"></a>算法核心介绍</h2><h3 id="Foggy-Image-model"><a href="#Foggy-Image-model" class="headerlink" title="Foggy Image model"></a>Foggy Image model</h3><p>首先，我们需要构建一个雾天图像的模型。公式如下所示，其中I表示雾天图像，J表示没有雾的图像，t表示空气穿透率，A表示纯雾。式子中的x均表示为图像中的像素点。</p>
<p><img src="/images/old-resources/fomula%201.jpg" alt="formula 1"></p>
<p>上式非常容易理解：我们最终看到的雾天图像是由透过空气传递过来的原始景观图像和一定浓度的雾叠加而成。</p>
<p>而作为去雾，我们是要依据已有的雾天图像I来得到原始的景观图像J，这就需要利用暗通道原理来求得模型中的空气穿透率t。</p>
<h3 id="暗通道"><a href="#暗通道" class="headerlink" title="暗通道"></a>暗通道</h3><p>基于观察，何凯明博士提出了这样的假设：自然界中的大部分非天空物体，其rgb三个颜色通道中至少有一个值非常低，其表达式如下所示：</p>
<p><img src="/images/old-resources/fomula%202.jpg" alt="formula 2"></p>
<p>其中Ω为x*x的像素方块。</p>
<p>下图是先取图像中三个通道的最小值构成一张灰度图，然后在做一个一定窗口大小的最小值滤波，最终得到暗通道处理图。</p>
<p><img src="/images/old-resources/image%201.JPG" alt="image 1"></p>
<p><img src="/images/old-resources/Min%28R,G,B%29%201.JPG" alt="image grey 1"></p>
<p><img src="/images/old-resources/After%20filter%201.JPG" alt="image dark channel 1"></p>
<p>通过处理图片我们可以清晰看出，除了白色的部分（三通道的值都比较大），其余部分的暗通道值很小，近似符合暗通道趋向0的假设。</p>
<h2 id="去雾模型推导"><a href="#去雾模型推导" class="headerlink" title="去雾模型推导"></a>去雾模型推导</h2><p>对于雾天模型的公式，我们现在做如下处理：</p>
<p><img src="/images/old-resources/fomula%203.jpg" alt="formula 3"></p>
<p>为了得到最终的去雾图像，我们需要求得t和A。推导过程如下所示：</p>
<p><img src="/images/old-resources/fomula%204.jpg" alt="formula 4"></p>
<p>由于即便在正常的天气中，原始景观传过来的时候也是经过了一定浓度的大气（可以认为是雾）。<br><br>而对于参数A，我们是这样计算的：选取一定区域内亮度最大的值作为A（理论上认为纯雾接近纯白）<br><br>这样就将t和A的值分别求了出来，从而得到去雾后的图像J。</p>
<p>采用这样的方法得到的图像如下所示：</p>
<p><img src="/images/old-resources/image%202.JPG" alt="image 2"><br><img src="/images/old-resources/J%202.JPG" alt="image 2 j"></p>
<p><img src="/images/old-resources/image%203.JPG" alt="image 3"><br><img src="/images/old-resources/J%203.JPG" alt="image 3 j"></p>
<p>由于在图像处理的过程中都不是基于一个像素而是一个像素集合的方块进行的，所以实际得到的图像中物体边缘会有比较明显的白边的存在，而对于这种现象，何凯明博士先后提出了两种理论予以解决。</p>
<h2 id="去除伪影"><a href="#去除伪影" class="headerlink" title="去除伪影"></a>去除伪影</h2><h3 id="Soft-Matting-2009"><a href="#Soft-Matting-2009" class="headerlink" title="Soft Matting 2009"></a>Soft Matting 2009</h3><p>该方法较为复杂，且处理较慢，早已不用，本文不做赘述</p>
<h3 id="Guided-Filter-导向滤波-2011"><a href="#Guided-Filter-导向滤波-2011" class="headerlink" title="Guided Filter 导向滤波 2011"></a>Guided Filter 导向滤波 2011</h3><p>导向滤波先做了一个如下的先验假设：所有邻近的点之间都是线性的，同时任何方程在局部的小段都可以认为是线性的。</p>
<p><img src="/images/old-resources/fomula%205.jpg" alt="formula 5"></p>
<p>经过推导可得：</p>
<p><img src="/images/old-resources/fomula%206.jpg" alt="formula 6"></p>
<p>其中q为输出图像，I为输入图像，p为滤波图像。i和k都是像素index，a和b是线性参数。在导向滤波中，I可以为任何导向图像</p>
<p>上述式子的一大优点就是其可以保护边界值。</p>
<p>通过上述式子我们可知，当像素强度变化不大时，a趋向于0而b等同于窗口的均值强度。等同于做一个均值滤波。</p>
<p>而当强度变化大时，a趋向于1而b趋向于0。等同于不做滤波，保留边界。</p>
<p>对之前的两张图片进行导向滤波处理，我们可以得到较好的结果。</p>
<p><img src="/images/old-resources/J_guild_filter%202.JPG" alt="image guided 2"></p>
<p><img src="/images/old-resources/J_guild_filter%203.JPG" alt="image guided 3"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我将展示一些去雾的效果：</p>
<p>去雾算法在处理非天空的自然物体时效果很好。如图：</p>
<p><img src="/images/old-resources/image%204.JPG" alt="image 4"><br><img src="/images/old-resources/J_guild_filter%204.JPG" alt="image guided 4"></p>
<p>同时在处理城市建筑时也有着不俗的表现。如图：</p>
<p><img src="/images/old-resources/image%205.JPG" alt="image 5"><br><img src="/images/old-resources/J_guild_filter%205.JPG" alt="image guided 5"></p>
<p>但是同时其也有着一些不足之处</p>
<p>比如在处理以白色物体为背景的图像时，会出现去雾效果不好以及色彩偏蓝的现象。这主要是因为去雾算法是基于暗通道值趋向为0的先验假设，而白色背景是不符合这种先验假设的，由于不符合物理模型所以才导致出错。如图：</p>
<p><img src="/images/old-resources/image%206.JPG" alt="image 6"><br><img src="/images/old-resources/J_guild_filter%206.JPG" alt="image guided 6"></p>
<p>此外当雾太厚的时候，还会出现过曝的情况，这是由于穿透参数t很小，根据之前的推导，我们会得到一个较大的J(x)。这才导致了过曝的现象。如图：</p>
<p><img src="/images/old-resources/image%207.JPG" alt="image 7"><br><img src="/images/old-resources/J_guild_filter%207.JPG" alt="image guided 7"></p>
<p>所以总而言之，去雾算法可以取得一个比较好的效果，不过也有其一定的局限性，要视具体的情况而定。</p>
<p>想要上手参考的，详见我的<a href="https://github.com/Htiango/cvpr09-defog">github</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Computer Vision</category>
      </categories>
      <tags>
        <tag>去雾算法</tag>
      </tags>
  </entry>
  <entry>
    <title>First Article</title>
    <url>/2016/11/23/First-Article/</url>
    <content><![CDATA[<p>浮生偷得几日闲，遂作此blog，望与有志者相识于此。</p>
<span id="more"></span>
<h2 id="What-will-be-in-this-blog"><a href="#What-will-be-in-this-blog" class="headerlink" title="What will be in this blog"></a>What will be in this blog</h2><h3 id="技术文"><a href="#技术文" class="headerlink" title="技术文"></a>技术文</h3><p>作为一名计算机专业的学生，开此blog的初衷自然是强化学习的动力，促进自己去研究前沿的知识，并以博文的形式与大家共享。</p>
<h3 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h3><p>“意皆有所郁结，不得通其道，故述往事,思来者”，自古这就是知识分子的通病，想来我也不能例外。在本blog中，我也会时不时将自己的所想所感放上来，权当一种情绪宣泄的途径，让各位见笑。</p>
<h3 id="游记"><a href="#游记" class="headerlink" title="游记"></a>游记</h3><p>二十余载间也游历了不少大好河山，附上游记既可为诸位提供行程指导，同时也为了加深这些美好的印象。</p>
<h3 id="趣谈"><a href="#趣谈" class="headerlink" title="趣谈"></a>趣谈</h3><p>Why so serious!? Let’s have some fun.</p>
<h2 id="What-won’t-be-in-this-blog"><a href="#What-won’t-be-in-this-blog" class="headerlink" title="What won’t be in this blog"></a>What won’t be in this blog</h2><h3 id="负能量"><a href="#负能量" class="headerlink" title="负能量"></a>负能量</h3><p>正如我们使用Python的理由——“life is short”，何苦牢骚满腹呢。虽说是情绪的宣泄，也只是抒发人生的思考，给出自己的见解，绝非自怨自艾，叹命途多舛，哀人生不公。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Start</tag>
      </tags>
  </entry>
</search>
